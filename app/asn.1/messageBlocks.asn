-- FIXME ADAPT NeoScrypt 

-- encryption: as specified in the key. If not specified default mode is ECB and default padding is PKCS1Padding

-- States: Tuple()=Value() [vallidity; allowed operations] {Store}
-- - Tuple(identity)=Value(messageQuota,transferQuota,sequence of Routingblocks for Error Message Routing) [validity; Requested at creation; may be extended upon request] {identityStore}
-- - Tuple(Identity,Serial)=maxReplays ['valid' from Identity Block; from First Identity Block; may only be reduced] {IdentityReplayStore}

Message-Blocks DEFINITIONS EXPLICIT TAGS ::= 
BEGIN

  -- define constants
  maxSerial             INTEGER ::= 4294967295      -- maximum serial number
  maxChunkSize          INTEGER ::= 4294967295      -- maximum size of a message chunk
  maxNumberOfReplays    INTEGER ::= 65535           -- maximum number of replys
  maxNumberOfRequests   INTEGER ::= 8               -- maximum number of administrative requests

  Message     ::= SEQUENCE { 
    headerKey     [1000] OCTET STRING OPTIONAL,  -- contains SymmetricKey encrypted with recipient nodes private key
    header        CHOICE { 
        encrypted [1001] OCTET STRING,  -- contains IdentityBlock structure; Decryption key is hosts private key
        plain     [1002] IdentityBlock  -- may be transmitted in plain (if empty)
    },
    blocks        CHOICE {
        encrypted [1101] OCTET STRING,     -- contains encrypted UnencryptedBlocks structure; Decryption key is in identity block [decryptionKey]
        plain     [1102] UnencryptedBlocks -- should not be used except for internal diagnostic purposes
    }
  }
  
  -- represents the identity of the rights owner
  IdentityBlock ::= SEQUENCE {
    -- Public key of the identity representing this transmission
    identityKey       AsymmetricKey,
    
    -- serial identifying this block
    serial            INTEGER (0..maxSerial), 
    
    -- number of times this block may be replayed (Tuple is identityKey,serial while 
    maxReplays        INTEGER (0..maxNumberOfReplays), 
    
    -- subsequent Blocks are not processed before valid time. 
    -- Host may reject too long retention. Recomended validity support >=1Mt.
    valid             UsagePeriod,        
    
    -- represents the chained secret which has to be found in subsequent blocks
    -- prevents reassembly attack
    forwardSecret [2000] ChainSecret OPTIONAL,
    
    -- contains SymmetricKey encrypted with private key of identityKey 
    -- encryption is done as proof of identity (identity hijack protection)
    decryptionKey     OCTET STRING,   -- contains (encrypted) DER encoded ASN1BitString with key representation
    
    -- contains administrative requests such as quota requests
    requests          SEQUENCE (SIZE (0..maxNumberOfRequests)) OF HeaderRequest ,
    
    -- padding and identitifier required to solve the cryptopuzzle
    identifier    [2001] INTEGER (0..maxSerial) OPTIONAL, 
    padding       [2002] OCTET STRING OPTIONAL  -- This is for solving crypto puzzles
  }

  UnencryptedBlocks ::= SEQUENCE {
    -- contains routing information (next hop) for the payloads
    -- FIXME how handle multiple payloads
    routing     [3000] RoutingBlock OPTIONAL,
    
    -- contains encrypted log data of the data traveling
    routingLog  [3010] RoutingLogBlock OPTIONAL,
    
    -- contains replys to header requests (eg. quota and identity handling)
    reply       [3020] ReplyBlock OPTIONAL,
    
    -- contains the actual payload
    payload     [3100] SEQUENCE (SIZE (0..128)) OF PayloadChunk  
  }

  
  -- represents the building and sending process for the next hop
  RoutingBlock ::= SEQUENCE {
  
    -- contains the next recipient in sequence
    recipient NodeSpec,
    
    -- contains the period when the payload should be processed 
    -- Router might refuse to long queue retention
    -- Recommended support for retention >=1h
    queueTime UsagePeriod,
    
    nextHop           SEQUENCE (SIZE (0..128)) OF NextHopBlock,   -- encrypted next RoutingBlocks for the payload
    
    -- contains the secret of the identity block (if any)
    forwardSecret     [111]   ChainSecret OPTIONAL,

    -- contains a routing block which may be used when sending error messages back to the quota owner
    -- this routing block may be cached for future use
    replyBlock [131]   RoutingBlock OPTIONAL,
    
    -- This section is required if payload is routed with a prebuilt RB (
    -- Messages MAY always request recompression (otherwise the message is identifyable from a non reply routing block)
    decryptionKey     [200] SEQUENCE (SIZE (1..2)) OF SymmetricKey OPTIONAL,
    encryptionKey     [201] SymmetricKey OPTIONAL,
    
    -- contains information for building replys
    cascade           [300] SEQUENCE(SIZE (0..255)) OF CascadeBuildInformation,
    ...
  }
  
  NextHopBlock ::= SEQUENCE {
    nextIdentityBlock   [13100] OCTET STRING,
    nextRoutingBlock    [13200] OCTET STRING,
    nextReplyBlock      [13300] OCTET STRING OPTIONAL,
    nextErrorReplyBlock [13400] OCTET STRING OPTIONAL
  }
  
  PayloadOperation ::= SEQUENCE{
    operation           PayloadType,
    thisid              [12010] INTEGER (0..65535)
  }
  
  PayloadType ::= CHOICE {
        randomPayload   [100] RandomPayloadOperation, 
        splitPayload    [150] SplitPayloadOperation, 
        mergePayload    [200] MergePayloadOperation,
        xorPayload      [250] XorPayloadOperation
  }
  
  CascadeBuildInformation ::= SEQUENCE {
    encryptionKey       SymmetricKey,
    secret              ChainSecret,
    payloadOp           PayloadOperation,
    ...
  }
  
  PercentSizeType ::= SEQUENCE {
    fromPercent         REAL (0..100),
    toPercent           REAL (0..100)
  }
  
  AbsoluteSizeType ::= SEQUENCE {
    fromAbsolute        INTEGER (0..maxChunkSize),
    toAbsolut           INTEGER (0..maxChunkSize)
  }
  
  SizeType ::= CHOICE {
    percent     [15001] PercentSizeType,
    absolute    [15101] AbsoluteSizeType
  }
  
  RandomPayloadOperation ::= SEQUENCE {
    size                SizeType
  }
 
  SplitPayloadOperation ::= SEQUENCE {
  }
 
  MergePayloadOperation ::= SEQUENCE {
    -- FIXME 
  }
 
  XorPayloadOperation ::= SEQUENCE {
    -- FIXME 
  }
 
  EncryptedRoutingLogBlock ::= OCTET STRING -- contains symmetrically encrypted RoutingLogBlock
  RoutingLogBlock ::= SEQUENCE {
    routingLog           SEQUENCE (SIZE (0..16)) OF RoutingLog,
    nestedRoutingInformationBlock EncryptedRoutingLogBlock     
  }
  
  RoutingLog ::=SEQUENCE   {
    nodeIdentifier    IA5String,
    time              GeneralizedTime,
    code              ErrorCode,
    information       IA5String
  }
  
  IdentityReplayStore ::= SEQUENCE {
	replays		SEQUENCE (SIZE (0..4294967295)) OF IdentityReplayBlock
  }
  
  IdentityReplayBlock ::= SEQUENCE {
    identity            AsymmetricKey,
    valid               UsagePeriod,
	replaysRemaining	INTEGER (0..4294967295)
  }

  IdentityStore ::= SEQUENCE {
    identities SEQUENCE (SIZE (0..4294967295)) OF IdentityStoreBlock
  }
  
  IdentityStoreBlock ::= SEQUENCE {
    valid               UsagePeriod,
    messageQuota        INTEGER (0..4294967295),
    transferQuota       INTEGER (0..4294967295),
    identity            [1001] AsymmetricKey OPTIONAL,    -- if omitted this is a node identity
    nodeAddress         [1002] NodeSpec      OPTIONAL,    -- if ommited own identity key
    nodeKey             [1003] AsymmetricKey OPTIONAL,    -- Contains the identity of the owning node; May be ommited if local node
    ...
  }
  
  -- contains a node spec of a routing point
  -- At the moment either smtp:<email> or xmpp:<jabber>
  NodeSpec ::= IA5String
  
  ChainSecret ::= INTEGER (0..4294967295)
  
  -- FIXME define requests
  HeaderRequest ::= CHOICE {
    identity      [0] HeaderRequestIdentity,
    capabilities  [1] HeaderRequestCapability,
    messageQuota  [2] HeaderRequestIncreaseMessageQuota,
    transferQuota [3] RequestIncreaseTransferQuota,
    quotaQuery    [4] HeaderRequestQueryQuota,
    ...
  }
  
  ReplyBlock ::= CHOICE {
    identity      [0] ReplyIdentity,
    capabilities  [1] ReplyCapability,
    ...
  }
  
  HeaderRequestIdentity ::= SEQUENCE {
    identity AsymmetricKey,
    period UsagePeriod,
    ...
  }
  
  ReplyIdentity ::= SEQUENCE {
    challenge     BIT STRING, -- bit sequence at beginning of hash from encrypted identity block
    hash          MacAlgorithmIdentifier,
    valid         UsagePeriod,
    identifier    INTEGER (0..4294967295),
    ...
  }
  
  HeaderRequestQueryQuota ::= SEQUENCE {
    identity AsymmetricKey,
    ...
  }
  
  HeaderRequestIncreaseMessageQuota ::= SEQUENCE {
    identity AsymmetricKey,
    messages INTEGER (0..4294967295),
    ...
  }
  
  RequestIncreaseTransferQuota ::= SEQUENCE {
    identity AsymmetricKey,
    size     INTEGER (0..4294967295),
    ...
  }
  
  HeaderRequestCapability ::= SEQUENCE {
    period UsagePeriod,
    ...
  }

  ReplyCapability ::= SEQUENCE {
    cypher            SEQUENCE (SIZE (2..256)) OF CypherSpec,
    maxTransferQuota  INTEGER (0..4294967295),
    maxMessageQuota   INTEGER (0..4294967295),
    supportedProtocol SEQUENCE OF Protocol,
    ...
  }
  
  CypherSpec ::= SEQUENCE {
      asymmetric AsymmetricAlgorithmIdentifier,
      symmetric  SymmetricAlgorithmIdentifier,
      mac       MacAlgorithmIdentifier
  }
  
  Protocol ::= ENUMERATED {
    smtp  (100),
    xmmp  (110),
    ...
  }
  
  ErrorCode ::= ENUMERATED {
    
    -- System messages
    ok                    (2001),
    transferQuotaStatus   (2101),
    messageQuotaStatus    (2102),
    
    -- protocol usage failures
    transferQuotaExceeded (3001),
    messageQuotaExceeded  (3002),
    identityUnknown       (3101),
    messageChunkMissing   (3201),
    messageLifeExpired    (3202), 
    
    -- Mayor host specific errors
    hostError             (5001),
    ...
  }
  
  PayloadChunk ::= SEQUENCE {
    offset                   INTEGER (0..MAX),
    routingBlockIdentifier   [0]   SEQUENCE (SIZE (0..255)) OF INTEGER, -- FIXME limit integer range
    payload                  [100] OCTET STRING
  }
  
  -- Compatible to PrivateKeyUsagePeriod taken from RFC3280
  UsagePeriod ::= SEQUENCE {
    notBefore       [0]     GeneralizedTime OPTIONAL,
    notAfter        [1]     GeneralizedTime OPTIONAL
 }
 
 -- adapted from RFC3280
  SymmetricAlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm               SymmetricAlgorithm,
    parameter               AlgorithmParameters OPTIONAL
  }

  AsymmetricAlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm               AsymmetricAlgorithm,
    parameter               AlgorithmParameters OPTIONAL
  }

  MacAlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm               MacAlgorithm,
    parameter               AlgorithmParameters
  }

  
  SymmetricAlgorithm ::= ENUMERATED {
    aes128      (1000),
    aes192      (1001),  -- optional support
    aes256      (1002),
    camellia128 (1100),
    camellia192 (1101),  -- optional support
    camellia256 (1102)
  }
  
  AsymmetricAlgorithm ::= ENUMERATED {
    rsa       (2000),
    dsa       (2100),
    secp384r1 (2500),
    sect409k1 (2501),
    secp521r1 (2502)
  }
  
  MacAlgorithm ::= ENUMERATED {
    sha384   (3000),
    sha512   (3001),
    -- FIXME check AEAD
    tiger192 (3100)
  }
  
  ECCurveType ::= ENUMERATED{
    secp192r1,
    sect163k1,
    sect163r2,
    secp224r1,
    sect233k1,
    sect233r1,
    secp256r1,
    sect283k1,
    sect283r1,
    secp384r1,
    sect409k1,
    sect409r1,
    secp521r1,
    sect571k1,
    sect571r1,
    ...
  }
  
  AlgorithmParameters ::= SEQUENCE {
    keySize   [10000] INTEGER (0..65535) OPTIONAL,
    curveType [10001] ECCurveType OPTIONAL,
    ...    
  }
  
  -- Symmetric key
  SymmetricKey ::= SEQUENCE {
    keyType SymmetricAlgorithmIdentifier,
    key     OCTET STRING
  }
  
  -- Asymmetric Key
  AsymmetricKey ::= SEQUENCE {
    keyType       AsymmetricAlgorithmIdentifier,
    publicKey     OCTET STRING,
    privateKey    [0] OCTET STRING OPTIONAL
  }
  
  pkcs-1    OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }

  -- FROM RFC5480
  id-ansi        OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) ansi-X9-62(10045) }
  id-certicom    OBJECT IDENTIFIER ::= { iso(1) identified-organization(3) certicom(132) }

  id-ecPublicKey OBJECT IDENTIFIER ::= { id-ansi keyType(2) 1 }

  dsaEncryption  OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 1 } -- RFC3279
  rsaEncryption  OBJECT IDENTIFIER ::= { pkcs-1 1 }

  secp192r1 OBJECT IDENTIFIER ::= { id-ansi  curves(3) prime(1) 1 }
  sect163k1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 1 }
  sect163r2 OBJECT IDENTIFIER ::= { id-certicom curve(0) 15 }
  secp224r1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 33 }
  sect233k1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 26 }
  sect233r1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 27 }
  secp256r1 OBJECT IDENTIFIER ::= { id-ansi curves(3) prime(1) 7 }
  sect283k1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 16 }
  sect283r1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 17 }
  secp384r1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 34 }
  sect409k1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 36 }
  sect409r1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 37 }
  secp521r1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 35 }
  sect571k1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 38 }
  sect571r1 OBJECT IDENTIFIER ::= { id-certicom curve(0) 39 }
  
END

