-- FIXME ADAPT NeoScrypt 

-- encryption: as specified in the key. If not specified default mode is ECB and default padding is PKCS1Padding

-- States: Tuple()=Value() [vallidity; allowed operations] {Store}
-- - Tuple(identity)=Value(messageQuota,transferQuota,sequence of Routingblocks for Error Message Routing) [validity; Requested at creation; may be extended upon request] {identityStore}
-- - Tuple(Identity,Serial)=maxReplays ['valid' from Identity Block; from First Identity Block; may only be reduced] {IdentityReplayStore}

Message-Blocks DEFINITIONS EXPLICIT TAGS ::= 
BEGIN

  -- define constants
  maxSerial                 INTEGER ::= 4294967295      -- maximum serial number
  maxChunkSize              INTEGER ::= 4294967295      -- maximum size of a message chunk
  maxNumberOfReplays        INTEGER ::= 127             -- maximum number a block may be replayed
  maxNumberOfRequests       INTEGER ::= 8               -- maximum number of administrative requests
  maxDurationOfProcessing   INTEGER ::= 86400           -- maximum number of seconds which the message might be delayed in the local queue (starting from startOffset)
  maxID                     INTEGER ::= 32767           -- maximum id of an operation
  maxRoutingBlocks          INTEGER ::= 127             -- maximum number of routing blocks in a message
  maxPayloadBlocks          INTEGER ::= 127             -- maximum number of payload blocks in a message
  maxTimeCachedProof        INTEGER ::= 86400           -- maximum number of seconds a proof of non revocation may be old
  
  PuzzleIdentifier          ::= OCTET STRING ( SIZE(0..16) )

  VortexMessage ::= SEQUENCE {
    prefix        CHOICE {
        plain           [10001] MessagePrefix,
        encrypted       [10002] OCTET STRING -- contains prefix encrypted with receivers public key
    },
    innerMessage  CHOICE {
        plain     [10011] InnerMessage,
        encrypted [10012] OCTET STRING -- contains inner message encrypted with Symmetric key from Prefix
    }
  }

  MessagePrefix ::= SEQUENCE {
    key             SymmetricKey
  }

  InnerMessage ::= SEQUENCE {
	padding		[11001] OCTET STRING,
	
	prefix      [11002] CHOICE {
        plain           [10001] MessagePrefix,
        encrypted       [10002] OCTET STRING -- contains prefix encrypted with receivers public key
    },
  
    identity    [11003] IdentityBlock,
    identitySignature OCTET STRING,   -- contains signature of Identity [as stored in identityBlock;signed unencrypted identityBlock without Tag]
	
    -- contains routing information (next hop) for the payloads
    routing     [11004] SEQUENCE (SIZE (0..maxRoutingBlocks)) OF RoutingBlock ,
    
    -- contains the actual payload
    payload     [11005] SEQUENCE (SIZE (0..maxPayloadBlocks)) OF PayloadChunk  

  }
  
  IdentityBlock ::= SEQUENCE {
    -- Public key of the identity representing this transmission
    identityKey       AsymmetricKey,
    
    -- serial identifying this block
    serial            INTEGER (0..maxSerial), 
    
    -- number of times this block may be replayed (Tuple is identityKey,serial while 
    maxReplays        INTEGER (0..maxNumberOfReplays), 
    
    -- subsequent Blocks are not processed before valid time. 
    -- Host may reject too long retention. Recomended validity support >=1Mt.
    valid             UsagePeriod,        
    
    -- represents the chained secret which has to be found in subsequent blocks
    -- prevents reassembly attack
    forwardSecret     ChainSecret,
    
    -- contains SymmetricKey encrypted with private key of identityKey 
    -- encryption is done as proof of identity (identity hijack protection)
    decryptionKeyPayload OCTET STRING,   -- contains DER encoded ASN1BitString with key representation
    decryptionKeyverify  OCTET STRING,   -- contains DER encoded ASN1BitString with key representation
    
    --  contains the MAC-Algorithm used for signing
    hash              MacAlgorithm,
    
    -- contains administrative requests such as quota requests
    requests          SEQUENCE (SIZE (0..maxNumberOfRequests)) OF HeaderRequest ,
    
    -- padding and identitifier required to solve the cryptopuzzle
    identifier    [12201] PuzzleIdentifier OPTIONAL,
    proofOfWork   [12202] OCTET STRING OPTIONAL  -- This is for solving crypto puzzles
  }

  -- represents the building and sending process for the next hop
  -- FIXME rework this part intensively (Missing features reply block for header requests; Insufficient handling of operation stack)
  RoutingBlock ::= SEQUENCE {
  
    -- contains the next recipient in sequence
    recipient NodeSpec,
    
    -- contains the period when the payload should be processed 
    -- Router might refuse to long queue retention
    -- Recommended support for retention >=1h
    minProcessTime INTEGER (0..maxDurationOfProcessing),
    maxProcessTime INTEGER (0..maxDurationOfProcessing),
    
    -- routing blocks for the next operation
    nextHop           SEQUENCE (SIZE (0..128)) OF NextHopBlock OPTIONAL,  
    
    -- contains the secret of the identity block
    forwardSecret     ChainSecret,

    -- contains a routing block which may be used when sending error messages back to the quota owner
    -- this routing block may be cached for future use
    replyBlock [131]   RoutingBlock OPTIONAL,
    
    -- contains information for building replys (when used as MURB ID 1 denotes original message)
    cascade           [300] SEQUENCE(SIZE (0..255)) OF PayloadOperation,
    replyCascade      [301] SEQUENCE(SIZE (0..255)) OF PayloadOperation
  }
  
  NextHopBlock ::= SEQUENCE {
    nextIdentityBlock   [13100] OCTET STRING,
    nextRoutingBlock    [13200] OCTET STRING,
    nextReplyBlock      [13300] OCTET STRING OPTIONAL,
    nextErrorReplyBlock [13400] OCTET STRING OPTIONAL,
    nextPayloadIdBlock  [13500] SEQUENCE (SIZE (0..maxPayloadBlocks)) OF INTEGER (1..maxID)
  }
  
  PayloadOperation ::= CHOICE {
        splitPayload    [150] SplitPayloadOperation, 
        mergePayload    [200] MergePayloadOperation,
        xorMergePayload [250] XorMergePayloadOperation,
		xorSplitPayload	[260] XorSplitPayloadOperation,
        encryptPayload  [300] EncryptPayloadOperation,
        decryptPayload  [350] DecryptPayloadOperation,
        addRedundancy   [400] AddRedundancyOperation,
        removeRedundancy[410] RemoveRedundancyOperation
  }
  
  PercentSizeType ::= SEQUENCE {
    fromPercent         REAL (0..100),
    toPercent           REAL (0..100)
  }
  
  AbsoluteSizeType ::= SEQUENCE {
    fromAbsolute        INTEGER (0..maxChunkSize),
    toAbsolut           INTEGER (0..maxChunkSize)
  }
  
  SizeType ::= SEQUENCE{
	size CHOICE {
		percent     [15001] PercentSizeType,
		absolute    [15101] AbsoluteSizeType
	}
  }
  
  AddRedundancyOperation ::= SEQUENCE {
    originalId				 [16000] INTEGER (0..maxID),
    stripes                  [16001] INTEGER (1..256),
    redundancy               [16002] INTEGER (1..256),
    keys                     [16003] SEQUENCE (SIZE (2..512)) OF SymmetricKey,
	newFirstId				 [16004] INTEGER (1..maxID)
  }
 
  RemoveRedundancyOperation ::= SEQUENCE {
    originalId				 [16000] INTEGER (0..maxID),
    stripes                  [16001] INTEGER (1..256),
    redundancy               [16002] INTEGER (1..256),
    keys                     [16003] SEQUENCE (SIZE (2..512)) OF SymmetricKey,
	newFirstId				 [16004] INTEGER (1..maxID)
  }

  SplitPayloadOperation ::= SEQUENCE {
    originalId				 INTEGER (0..maxID),
    firstSize                SizeType,
	newFirstId				 INTEGER (1..maxID),
	newSecondId				 INTEGER (1..maxID)
  }

  MergePayloadOperation ::= SEQUENCE {
    originalFirstId			 INTEGER (0..maxID),
    originalSecondId		 INTEGER (0..maxID),
	newId			    	 INTEGER (1..maxID)
  }
 
  XorMergePayloadOperation ::= SEQUENCE {
    originalFirstId			 INTEGER (0..maxID),
    originalSecondId		 INTEGER (-1..maxID),
    originalFirstSize        SizeType,
	newId			    	 INTEGER (1..maxID)
  }
 
  XorSplitPayloadOperation ::= SEQUENCE {
    originalId			     INTEGER (0..maxID),
    prngSpec                 PRNGSpec,
	newFirstBlockId			 INTEGER (1..maxID),
	newSecondBlockId		 INTEGER (1..maxID)
  }

  EncryptPayloadOperation ::= SEQUENCE {
    originalId		        INTEGER (0..maxID),
    key                     SymmetricKey,
	newId	    	    	INTEGER (1..maxID)
  }
 
  DecryptPayloadOperation ::= SEQUENCE {
    originalId		        INTEGER (0..maxID),
    key                     SymmetricKey,
	newId	    	    	INTEGER (1..maxID)
  }

  IdentityReplayStore ::= SEQUENCE {
	replays		SEQUENCE (SIZE (0..4294967295)) OF IdentityReplayBlock
  }
  
  IdentityReplayBlock ::= SEQUENCE {
    identity            AsymmetricKey,
    valid               UsagePeriod,
	replaysRemaining	INTEGER (0..4294967295)
  }

  IdentityStore ::= SEQUENCE {
    identities SEQUENCE (SIZE (0..4294967295)) OF IdentityStoreBlock
  }
  
  IdentityStoreBlock ::= SEQUENCE {
    valid               UsagePeriod,
    messageQuota        INTEGER (0..4294967295),
    transferQuota       INTEGER (0..4294967295),
    identity            [1001] AsymmetricKey OPTIONAL,    -- if omitted this is a node identity
    nodeAddress         [1002] NodeSpec      OPTIONAL,    -- if ommited own identity key
    nodeKey             [1003] SEQUENCE OF AsymmetricKey OPTIONAL,    -- Contains the identity of the owning node; May be ommited if local node
    routingBlocks       [1004] SEQUENCE OF RoutingBlock OPTIONAL,
    replayStore         [1005] IdentityReplayStore,
    puzzle              [1006] ReplyPuzzleRequired OPTIONAL
  }
  
  -- contains a node spec of a routing point
  -- At the moment either smtp:<email> or xmpp:<jabber>
  NodeSpec ::= IA5String
  
  ChainSecret ::= INTEGER (0..4294967295)
  
  HeaderRequest ::= CHOICE {
    identity      [0] HeaderRequestIdentity,
    capabilities  [1] HeaderRequestCapability,
    messageQuota  [2] HeaderRequestIncreaseMessageQuota,
    transferQuota [3] HeaderRequestIncreaseTransferQuota,
    quotaQuery    [4] HeaderRequestQueryQuota
  }
  
  ReplyBlock ::= CHOICE {
    identity      [0] ReplyIdentity,
    capabilities  [1] ReplyCapability,
    puzzle        [2] ReplyPuzzleRequired,
    error          [99] ErrorBlock
  }
  
  ReplyIdentity ::= SEQUENCE {
    -- FIXME this has to be done
  }

  HeaderRequestIdentity ::= SEQUENCE {
    identity AsymmetricKey,
    period UsagePeriod
  }
  
  ReplyPuzzleRequired ::= SEQUENCE {
    challenge     BIT STRING, -- bit sequence at beginning of hash from encrypted identity block
    hash          MacAlgorithmIdentifier,
    valid         UsagePeriod,
    identifier    INTEGER (0..4294967295)
  }
  
  HeaderRequestQueryQuota ::= SEQUENCE {
    identity AsymmetricKey
  }
  
  HeaderRequestIncreaseMessageQuota ::= SEQUENCE {
    identity AsymmetricKey,
    messages INTEGER (0..4294967295)
  }
  
  HeaderRequestIncreaseTransferQuota ::= SEQUENCE {
    identity AsymmetricKey,
    size     INTEGER (0..4294967295)
  }
  
  HeaderRequestCapability ::= SEQUENCE {
    period UsagePeriod
  }

  ReplyCapability ::= SEQUENCE {
    cypher            SEQUENCE (SIZE (2..256)) OF CypherSpec,
    maxTransferQuota  INTEGER (0..4294967295),
    maxMessageQuota   INTEGER (0..4294967295),
    supportedProtocol SEQUENCE OF Protocol
  }
  
  CypherSpec ::= SEQUENCE {
      asymmetric AsymmetricAlgorithmIdentifier,
      symmetric  SymmetricAlgorithmIdentifier,
      mac       MacAlgorithmIdentifier
  }
  
  Protocol ::= ENUMERATED {
    smtp  (100),
    xmmp  (110),
    ...
  }

  ErrorBlock ::= SEQUENCE {
    code            ErrorCode,
    request         HeaderRequest,
    ...
  }
  
  ErrorCode ::= ENUMERATED {
    
    -- System messages
    ok                    (2001),
    transferQuotaStatus   (2101),
    messageQuotaStatus    (2102),
    
    -- protocol usage failures
    transferQuotaExceeded (3001),
    messageQuotaExceeded  (3002),
    identityUnknown       (3101),
    messageChunkMissing   (3201),
    messageLifeExpired    (3202),
    puzzleUnknown         (3301),
	
	-- capability errors
	macAlgorithmUnknown         (3801),
	symmetricAlgorithmUnknown   (3802),
	asymmetricAlgorithmUnknown  (3803),
	prngAlgorithmUnknown        (3804),
	missingParameters           (3820),
	badParameters               (3821),
    
    -- Mayor host specific errors
    hostError             (5001),
    ...
  }
  
  PayloadChunk ::= SEQUENCE {
    id                        INTEGER (0..maxID),
    routingBlockForwardSecret INTEGER (0..maxSerial),
    payload                 CHOICE {
      payload                   [100] OCTET STRING,
      replyBlock                [101] ReplyBlock
    }
  }
  
  UsagePeriod ::= SEQUENCE {
    notBefore       [0]     GeneralizedTime OPTIONAL,
    notAfter        [1]     GeneralizedTime OPTIONAL
 }
 
  SymmetricAlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm               SymmetricAlgorithm,
    padding                 CypherPadding,
    mode                    CypherMode,
    parameter               AlgorithmParameters OPTIONAL
  }

  AsymmetricAlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm               AsymmetricAlgorithm,
    parameter               AlgorithmParameters OPTIONAL
  }

  MacAlgorithmIdentifier  ::=  SEQUENCE  {
    algorithm               MacAlgorithm,
    parameter               AlgorithmParameters
  }

  PRNGSpec ::= SEQUENCE {
    type                PRNGType,
    seed                OCTET STRING
  }
  
  PRNGType ::= ENUMERATED {
    xsadd       (1000),
    blumMicali  (1001)
  }

  SymmetricAlgorithm ::= ENUMERATED {
    aes128      (1000),
    aes192      (1001),  -- optional support
    aes256      (1002),
    camellia128 (1100),
    camellia192 (1101),  -- optional support
    camellia256 (1102)
  }
  
  CypherMode ::= ENUMERATED {
    ecb      (1000),
    cbc      (1001)
  }

  CypherPadding ::= ENUMERATED {
    pkcs7      (1000),
    pkcs1      (1001)
  }
  
  AsymmetricAlgorithm ::= ENUMERATED {
    rsa       (2000),
    dsa       (2100),
    ec        (2500)
  }
  
  MacAlgorithm ::= ENUMERATED {
    sha384   (3000),
    sha512   (3001),
    tiger192 (3100)
  }
  
  ECCurveType ::= ENUMERATED{
    secp384r1 (2500),
    sect409k1 (2501),
    secp521r1 (2502),
    ...
  }
  
  AlgorithmParameters ::= SEQUENCE {
    keySize              [10000] INTEGER (0..65535) OPTIONAL,
    curveType            [10001] ECCurveType OPTIONAL,
    initialisationVector [10002] OCTET STRING OPTIONAL,
    nonce                [10003] OCTET STRING OPTIONAL,
    mode                 [10004] OCTET STRING OPTIONAL,
    padding              [10005] OCTET STRING OPTIONAL
  }
  
  -- Symmetric key
  SymmetricKey ::= SEQUENCE {
    keyType SymmetricAlgorithmIdentifier,
    key     OCTET STRING (SIZE(1..512))
  }
  
  -- Asymmetric Key
  AsymmetricKey ::= SEQUENCE {
    keyType       AsymmetricAlgorithmIdentifier,
    publicKey     [1] OCTET STRING,
    privateKey    [2] OCTET STRING OPTIONAL
  }
  
END

