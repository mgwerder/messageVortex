<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd"[ ]>

<!-- FIXME: replaceIdentity needs to be documented -->
<!-- FIXME: content for end of padding needs to be repeatable PRNG output -->
<!-- FIXME: escaping of special blocks should only escape backslash at position 0 of payload -->
<!-- FIXME: extend reply capability with the following properties:
			- Maximum number of simultaneous valid header serials.
			- Maximum number of simultaneous valid building operations.
			- Maximum identity lifespan in seconds.
-->			
<!-- FIXME: add validity to the requirement block -->
<!-- FIXME: correct F5 encoding String according to spec in thesis ( do not forget escaping of "\", "," and ")" -->
<!-- FIXME: add "All SMTP nodes responding to clear text should at least support $encoding=plain:0,256$." -->
<!-- FIXME: Add header request peer -->
<!-- FIXME: Switch from XEP0096 to XERP0234 as XEP0096 has been depreciated -->

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="exp" docName="draft-gwerder-messagevortexmain-01" ipr="trust200902" xml:lang="en">
    <!-- FIXME add message content outline (mime message with selected header lines) -->
    <!-- FIXME explain routing and ephemeral identities better -->
    <!-- FIXME remove CTR as it heroically fails on IV/key reuse - Mention key/IV reuse -->
    <!-- FIXME add definition of MURB -->
    <!-- FIXME maybe rework padding -->
    <front>

        <title>MessageVortex Protocol</title>

        <author fullname="Martin Gwerder" surname="Gwerder">
            <address>
                <postal>
                    <street>Untere Parkstrasse 9</street>
                    <code>5212</code><city>Hausen</city><region>AG</region>
                    <country>Switzerland</country>
                </postal>
                <phone>+41 56 202 76 81</phone>
                <email>rfc@messagevortex.net</email>

            </address>
        </author>

        <date year="2018"/>

        <area>General</area>

        <workgroup>Internet Engineering Task Force</workgroup>

        <keyword>SMTP</keyword>
        <keyword>XMPP</keyword>
        <keyword>IMAPrev4</keyword>
        <keyword>MessageVortex</keyword>
        <keyword>Anonymity</keyword>

        <abstract>
            <t>
                MessageVortex Protocol specifies messages embedded within existing transfer protocols such  as SMTP or XMPP to send them anonymously from peer to peer.
            </t>
            <t>
                The protocol outperforms other protocols by decoupling transport from the final transmitter and receiver party. There is no trust put into any infrastructure except for the infrastructure of the sending and receiving party of a message. The Message flow is entirely selected by the creator of the routing block. Routing nodes gain no non-obvious knowledge about messages even when collaborating. Third-party anonymity is always achieved. Furthermore, one out of sender and receiver anonymity may be achieved.
            </t>
        </abstract>
    </front>

    <middle>
        <section title="Introduction">
            <t>
                Anonymization is hard to achieve. Most of the attempts in the past rely on either trust in a dedicated infrastructure or a specialized networking protocol.
            </t>
            <t>
                Instead of defining a transport layer, MessageVortex piggybacks on other transport protocols. Messages are being transported alongside ordinary messages of that transport protocol. A blending layer picks the messages up, applies local operations to it and resends the new chunks to the next recipients.
            </t>
            <t>
                A processing node learns as little as possible from the message due to the nature of the operations processed. The onionized structure of the protocol makes it impossible to follow the trace of a message without having control over the processing node itself.
            </t>
            <t>
                MessageVortex is a protocol which allows sending and receiving messages by using a routing block instead of a destination address.
                The sender has full control over all parameters of the message flow.
            </t>
            <t>
                A message is split and reassembled during transmission. Chunks of the message may carry redundant information to avoid service interruptions of the message transit. Decoy traffic and message traffic are not differentiable as the nature of the addRedundancy operation allows each generated part to be a message part or decoy. Any routing node is thus unable to differentiate between the message and decoy traffic.
            </t>
            <t>
                Any Receiver knows after processing whether a message is destined for it (it creates a chunk with ID 1) or other nodes (processing instructions only). Due to the missing keys, no other node may do this processing.
            </t>
            <t>
                This RFC starts with the general terminology (see <xref target="entities_overview"/>). Next, a general overview of the process is given (see <xref target="layer_overview"/>). Lastly, the subsequent sections describe the details of the protocol.
            </t>

            <section title="Requirements Language">
                <t>
                    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.
                </t>
            </section>

            <section title="Protocol Specification">
                <t>
                    <xref target="asn_one"/> specifies all relevant parts of the protocol in ASN.1 (see <xref target="CCITT.X680.2002"/> and <xref target="CCITT.X208.1988"/>). The blocks are, if not otherwise mentioned, DER encoded.
                </t>
            </section>

            <section title="Number Specification">
                <t>
                    All numbers within this document are, if not suffixed, decimal numbers. Numbers suffixed with a small letter 'h' followed by two hex digits are octets in hex writing. A blank in ASCII (' ') is written as 20h and a capital 'K' in ASCII as 4Bh.
                </t>
            </section>
        </section>

        <section anchor="entities_overview" title="Entities Overview">
            <t>Within this document, we refer to the entities as defined below. </t>
            <section anchor="entities_node" title="Node">
                <t>
                    We use the term 'node' to  describe any system connected to other nodes, and supporting the MessageVortex Protocol. A 'node address' is typically an email address, an XMPP address, or any other transport protocol identity supporting the MessageVortex protocol. Any address SHOULD include a public part of an 'identity key' allowing to transmit messages safely. One or more addresses MAY belong to the same node.
                </t>
                <section anchor="entities_node_spec" title="NodeSpec">
                    <t>
                        Every addressable node is addressed in a unified format stored in a nodeSpec block. This RFC specifies transport layers for XMPP and SMTP. Adding transport layers requires to write an extension to this RFC.
                    </t>
                    <section anchor="entities_node_spec_smtp" title="NodeSpec for SMTP nodes">
                        <t>
                            Typically a node specification is specified with the ASN.1 block NodeSpec (see <xref target="asnOne_helpers"/>).
                            To allow addressing of a vortex node with an ordinary client an alternative representation SHOULD be supported as defined below as smtpAlternateSpec (specification noted in ABNF as specified in <xref target="RFC5234"/>).
                            <figure>
                                <artwork type="abnf"><![CDATA[
localPart         = <local part of address>
domain            = <domain part of address>
email             = localPart "@" domain
keySpec           = <BASE64 encoded AsymmetricKey; DER representation>;
smtpAlternateSpec = localPart ":" keySpec "@" domain
                                ]]></artwork>
                            </figure>
                        </t>
                    </section>
                    <section anchor="entities_node_spec_spec" title="NodeSpec for XMPP nodes">
                        <t>
                            Typically a node specification is specified with the ASN.1 block NodeSpec.
                            To allow addressing of a vortex node with an ordinary client, an alternative representation SHOULD be supported as defined below as jidAlternateSpec (specification noted in ABNF as specified in <xref target="RFC5234"/>).
                            <figure>
                                <artwork type="abnf"><![CDATA[
localPart         = <local part of address>
domain            = <domain part of address>
jid               = localPart "@" domain [ "/" resourcepart ]
keySpec           = <BASE64 encoded AsymmetricKey; DER representation>;
jidAlternateSpec = localPart ":" keySpec "@" domain [ "/" resourcepart
                                ]]></artwork>
                            </figure>
                        </t>
                        <t>
                            Please note that the ":" character (3Ah) is explicitly excluded in <xref target="RFC7622"/> in the localpart.
                        </t>
                    </section>
                </section>
            </section>
            <section anchor="entities_peer" title="Peer Partner">
                <t>
                    We use the term 'peer partner' as two or more message sending or receiving entities. One of these peer partners sends a message, and all other peer partners receive one or more messages. Peer partners are message specific. Every peer partner always connects directly to a node.
                </t>
            </section>
            <section anchor="entities_keys" title="Encryption keys">
               <t>
                   There are several keys required for a Vortex message. For identities and ephemeral identities (see below) we use asymmetric keys. For message encryption, we use symmetric keys.
               </t>
               <section anchor="entities_node_identity" title="Identity Keys">
                   <t>
                       Every participant of the network has an asymmetric key. These keys SHOULD be either EC keys with a minimum length of 384 bits or RSA keys with a minimum length of 2048 bits.
                   </t>
                   <t>
                       The public key needs to be known by all parties writing to or through that node.
                   </t>
               </section>
               <section anchor="entities_keys_peer" title="Peer Key">
                   <t>
                       Peer keys are symmetrical keys transmitted with a Vortex message. Peer keys are always known to the node sending a message, the node receiving the message from the sender, and to the creator of the routing block.
                   </t>
                   <t>
                       A peer key is included in the identity block of a Vortex message and in the building instructions for a Vortex message (see RoutingCombo in <xref target="asn_one"/>).
                   </t>
               </section>
               <section anchor="entities_keys_sender" title="Sender Key">
                   <t>
                       The sender key is a symmetrical key protecting the identity and routing block of a Vortex message. It is encrypted with the receiving peer key and prefixed to the identity block. This key decouples further identity and processing information from the previous key.
                   </t>
                   <t>
                       A sender key is known to precisely one peer of a Vortex message and the creator of the routing block.
                   </t>
               </section>
            </section>
            <section anchor="entities_vortex_message" title="Vortex Message">
                <t>
                    We use the term 'Vortex message' for a single transmission between two routing layers. A 'blended Vortex message' describes a Vortex message which has been adapted to the transport layer by the blending layer (see <xref target="layer_overview"/>).
                </t>
                <t>
                    A full vortex message contains the following items:
                    <list style="symbols">
                        <t>The peer key (encrypted with the host key of the node; stored in a PrefixBlock) protecting the inner Vortex message (innerMessageBlock).</t>
                        <t>The small padding guarantees that a replayed routing block with different content does not look alike.</t>
                        <t>The sender key (encrypted with the host key of the node) protecting the identity and routing block.</t>
                        <t>The identity block (protected by the sender key) containing information about the ephemeral identity of the sender, replay protection information, header requests (optional) and a requirement reply (optional).</t>
                        <t>The routing block (protected by the sender key) containing information on how subsequent messages are processed, assembled and blended.</t>
                        <t>The payload block (protected by the peer key) contains payload chunks for processing.</t>
                    </list>
                </t>
            </section>
            <section anchor="entities_message" title="Message">
                <t>
                    A Message is a content to be transmitted from one sender to the recipient. The Sender uses a routing block to achieve this which is either built by him or provided by the receiver. A Message may be anonymous. There are however different degrees of anonymity:

                    <list style="symbols">
                        <t>If the sender of a message is not known to anyone else except the sender, we refer to that as 'sender anonymity.'</t>
                        <t>If the receiver of a message is not known to anyone else except the receiver, we refer to that as 'receiver anonymity.'</t>
                        <t>If an attacker is unable to determine content, original sender, and final receiver, we refer to that as third-party anonymity.</t>
                        <t>If a sender or a receiver may be determined as "one of a set of &lt;k&gt; entities we refer to it as k-anonymity (for more about this see <xref target="KAnon"/>).</t>
                    </list>
                </t>
                <t>
                    A message is always MIME encoded as specified in <xref target="RFC2045"/>.
                </t>
            </section>
            <section anchor="keys" title="Key and MAC specifications and usages">
                <t>
                    MessageVortex uses a unique encoding for keys. It is designed to be small and flexible while maintaining a specific base structure.
                </t>
                <t>
                    The following key structures exist:
                    <list style="symbols">
                        <t>SymmetricKey</t>
                        <t>AsymmetricKey</t>
                    </list>
                </t>
                <t>
                    MAC does not need a complete structure containing specs and value. Instead only a  MacAlgorithmSpec is available. The following sections outline the constraints when specifying parameters for these structures. A node MUST NOT specify any parameter more than once.
                </t>
                <t>
                    If a crypto mode is specified requiring an IV, a node MUST provide the IV when specifying the key.
                </t>
                <section anchor="asymmetricKey" title="Asymmetric Keys">
                    <t>
                        Nodes use asymmetric keys for identifying peer nodes (identities) and encrypting symmetric keys (for later de-/encryption of payload or blocks). All asymmetric keys MUST contain a key type specifying a strictly normed key. They MUST contain a public part of the key encoded as X.509 container and a private key as specified in PKCS#8 wherever possible.
                    </t>
                    <t>
                        RSA and EC keys must contain a keysize parameter. All asymmetric keys SHOULD contain a padding parameter. A node SHOULD assume PKCS#1 if no padding is specified.
                    </t>
                    <t>
                        NTRU specification MUST provide parameters "n", "p", and "q". McEliece specification MUST contain parameters "n", "k", and "t".
                    </t>
                </section>
                <section anchor="symmetricKey" title="Symmetric Keys">
                    <t>
                        Nodes use symmetric keys for encrypting payload and control blocks. All symmetric keys MUST contain a key type specifying a strictly normed key. They MUST contain a key encoded.
                    </t>
                    <t>
                        A node MUST provide a keysize parameter if the key (or equivalently block) size is not standardized or encoded in the name. All symmetric key specification MUST contain a mode and padding parameter. A node MAY list multiple padding or mode parameters in a ReplyCapability block to give the recipient a free choice.
                    </t>
                </section>
            </section>
            <section anchor="entities_blocks" title="Blocks">
                <t>We use the term 'block' for an ASN.1 sequence in a transmitted message. We embed messages in the transport protocol. It may have any size.</t>
            </section>
            <section anchor="entities_transport_address" title="Transport Address">
                <t>We use the term 'transport address' for the token required to address the next immediate node on the transport layer.  An email transport layer would have SMTP addresses such as 'vortex@example.com' as transport address.</t>
            </section>
            <section anchor="entities_identity" title="Identity">
                <section anchor="entities_identity_peer" title="Peer Identity">
                    <t>The peer identity may contain the following information of a peer partner:
                        <list style="symbols">
                            <t>A transport address (always) and the public key of this identity (given there is no recipient anonymity)</t>
                            <t>The routing blocks for contacting the identity (optional; this block is only required in the case of recipient anonymity)</t>
                            <t>The private key (only known by the owner of the identity)</t>
                        </list>
                    </t>
                </section>
                <section anchor="entities_identity_ephemeral" title="Ephemeral Identity">
                    <t>
                        Ephemeral identities are temporary identities created on a single node. These identities MUST NOT relate to any other identity. They allow bookkeeping for a node. To each ephemeral identity is a workspace assigned. Every ephemeral identity may have multiple quotas assigned.
                    </t>
                </section>
                <section anchor="entities_identity_official" title="Official Identity">
                    <t>An official identity may have the following items assigned:
                        <list style="symbols">
                            <t>Routing blocks to be used to reply to the node.</t>
                            <t>A list of assigned ephemeral identities on all other nodes and their projected quotas.</t>
                            <t>A list of known nodes and the respective node identity</t>
                        </list>
                    </t>
                </section>
            </section>
            <section anchor="entities_workspace" title="Workspace">
                <t>Every official or ephemeral identity has a workspace. A workspace consists of the following elements:
                    <list style="symbols">
                        <t>Zero or more routing blocks to be processed</t>
                        <t>Slots for payload block sequentially numbered. Every slot...
                            <list style="symbols">
                                <t>MUST contain a numerical ID identifying the slot</t>
                                <t>MAY contain a payload content</t>
                                <t>If a block contains a payload, it MUST contain a validity period.</t>
                            </list>
                        </t>
                    </list>
                </t>
            </section>
        </section>

        <section anchor="layer_overview" title="Layer Overview">
            <t>The protocol is designed in four layers as shown in <xref target="fig_layer_overview" /></t>

            <figure anchor="fig_layer_overview" title="Layer overview">
                <artwork align="center" src="blockLayoutSimplified.png"><![CDATA[
+-------------------------------------------------------------------+
| Vortex Node                                                       |
| +---------------------------------------------------------------+ |
| |                        Accounting                             | |
| |_______________________________________________________________| |
|                                                                   |
| +---------------------------------------------------------------+ |
| |                          Routing                              | |
| |_______________________________________________________________| |
|                                                                   |
| +----------------------------+ +--------------------------------+ |
| |           Blending         | |             Blending           | |
| |____________________________| |________________________________| |
|___________________________________________________________________|
  +----------------------------+ +--------------+ +---------------+
  |          Transport         | | Transport in | | Transport out |
  |____________________________| |______________| |_______________|
               ]]></artwork>
            </figure>

            <t>
                Every participating node MUST implement the layers blending, routing, and accounting.  There MUST be at least one incoming and one outgoing transport layer available to a node. All blending layers SHOULD connect to respective Transport layers for sending and receiving packets.
            </t>

            <section anchor="layer_overview_transport" title="Transport Layer">
                <t>The transport layer embeds the blended MessageVortex packets into the data stream of the existing transport layer protocol.</t>
                <t>The transport layer infrastructure SHOULD NOT be specific to anonymous communication and should contain significant parts of non-MessageVortex traffic.</t>
            </section>

            <section anchor="layer_overview_blending" title="Blending Layer">
                <t>The blending layer embeds MessageVortex packets into the transport layer data stream and extracts MessageVortex packets from the transport layer.</t>
            </section>
            <section anchor="layer_overview_routing" title="Routing Layer">
                <t>The Routing Layer expands information contained in MessageVortex packets, processes them, and passes generated  packets to the respective Blending Layer.</t>
            </section>
            <section anchor="layer_overview_accounting" title="Accounting Layer">
                <t>The accounting layer keeps track of all ephemeral identities authorized to use a MessageVortex node. Especially it verifies the available quotas to an ephemeral identity.
                </t>
            </section>
        </section>

        <section title="Vortex Message">
            <section title="Overview">
                <t>
                    <xref target="fig_message_overview"/> shows a Vortex message. The enclosed sections denote encrypted blocks. The three to four letter abbreviations denote the key required for decryption. The abbreviation k_h stands for the asymmetric host key. sk_p is the symmetric peer key. The receiving node obtains this key by decrypting MPREFIX with its host key k_h. sk_s is the symmetric sender key. When decrypting the MPREFIX block, the node obtains this key. The sender key protects the header and the routing blocks. This key guarantees that the node assembling the message does not know about upcoming identities, operations, and requests. The peer key protects the message including structure from any third party observer.
                    <figure anchor="fig_message_overview" title="Vortex message overview">
                        <artwork align="center"><![CDATA[
+-+---+-+-+---+-+---+-+-+---+-+-+---+-+-------+-+
| |   | | |   | | C | | |   | | | R | |       | |
| |   | | |   | | P | | | H | | | O | |       | |
| | M | | | P | | R | | | E | | | U | |   P   | |
| | P | | | A | | E | | | A | | | T | |   A   | |
| | R | | | D | | F | | | D | | | I | |   Y   | |
| | E | | | D | | I | | | E | | | N | |   L   | |
| | F | | | I | | X | | | R | | | G | |   O   | |
| | I | | | N | +---+ | |___| | |___| |   A   | |
| | X | | | G |  k_h  | sk_s  | sk_s  |   D   | |
| |___| | |___|_______|_______|_______|_______| |
|  k_h  |                  sk_p                 |
|_______|_______________________________________|
                        ]]></artwork>
                    </figure>
                </t>
            </section>
            <section title="Message Prefix Block (MPREFIX)">
                <t>
                    The PrefixBlock contains a symmetrical key as defined in <xref target="asnOne_schema"/> and is encrypted using the host key of the receiving peer host. The symmetric key used MUST be one out of the set advertised by a CapabilitiesReplyBlock (see <xref target="routing_header_req_cap"/>). A node MAY choose any parameters omitted in the CapabilitiesReplyBlock freely (unless stated otherwise in <xref target="routing_header_req_cap"/>). A node SHOULD avoid sending unencrypted PrefixBlocks. A prefix block MUST contain the same forward-secret as the other prefix, the routing block, and the header block. A host MAY reply to a message with an unencrypted message block. Any reply to a message SHOULD be encrypted.
                </t>
                <t>
                    The sender MUST choose a key which may be encrypted with the host key using the padding advertised by the CapabilitiesReplyBlock.
                </t>
            </section>
            <section title="Inner Message Block">
                <t>
                    A node MUST always encrypt (with the symmetric key of the PrefixBlock) an InnerMessageBlock. The encryption hides the inner structure of the message. The InnerMessageBlock SHOULD always accommodate four or more payload chunks.
                </t>
                <t>
                    An InnerMessageBlock always starts with a padding block. This padding guarantees that when using the same routing block multiple times, its binary structure is not repeated throughout the messages with the same routing block. The padding MUST be the first 16 bytes of the first four non-empty payload chunks (PayloadChunks). If a payload chunk is shorter than 16 bytes, the content of the padding SHOULD be filled with zero-valued bytes (00h) at very end up to the required number of bytes. An inner message block (InnerMessageBlock) SHOULD contain at least four payload chunks sized 16 bytes or bigger. If there are less than four payload chunks, then the padding MUST contain a random sequence of 16 bytes for the missing payload chunks. A node MUST NOT reuse random sequences.
                </t>
                <t>
                    An InnerMessageBlock contains so-called forwardSecrets. This random number MUST be the same in the HeaderBlock, the RoutingBlock, and the PrefixBlock. Nodes receiving Messages containing non-matching forwardSecrets MUST discard these messages, and SHOULD NOT send an error message.
                </t>
                <section title="Control Prefix Block">
                    <t>
                        Control prefix block (CPREFIX) and MPREFIX block share the same structure and logic. It contains the sender key sk_s. If an MPREFIX block was unencrypted, a node MAY omit the CPREFIX block. An omitted CPREFIX block results in unencrypted control blocks (HeaderBlock and RoutingBlock).
                    </t>
                    <t>
                        A prefix block MUST contain the same forwardSecret as the other prefix, the routing block, and the header block.
                    </t>
                </section>
                <section title="Control Blocks">
                    <t>
                        The control blocks contain the core information to process the payload. It contains a HeaderBlock and a RoutingBlock.
                    </t>
                    <section title="Header Block">
                        <t>
                            The header block (see HeaderBlock in <xref target="asn_one"/>) contains the following information:
                            <list style="symbols">
                                <t>It MUST contain the local ephemeral identity of the routing block builder.</t>
                                <t>It MAY contain header requests.</t>
                                <t>It MAY contain the solution to a PuzzleRequired block  previously opposed in a header request.</t>
                            </list>
                        </t>
                        <t>
                            The list of header requests MAY one of the following:
                            <list style="symbols">
                                <t>be empty</t>
                                <t>contain a single identity create request (HeaderRequestIdentity)</t>
                                <t>contain a single increase quota request</t>
                            </list>
                            If a header block violates these rules, then a node MUST NOT reply to any header requests. Payload and routing blocks SHOULD still be added to the workspace and processed, given the message quota is not exceeded.
                        </t>
                    </section>
                    <section title="Routing Block">
                        <t>
                            The routing block (see RoutingBlock in <xref target="asn_one"/>) contains the following information:
                            <list style="symbols">
                                <t>It MUST contain a serial number uniquely identifying the routing block of this user. A serial number MUST be unique during the lifetime of a routing block.</t>
                                <t>It MUST contain the same forward secret as the two prefix blocks and the header block.</t>
                                <t>It MAY contain assembly and processing instructions for subsequent messages.</t>
                                <t>It MAY contain a reply block for messages assigned to the owner of the identity.</t>
                            </list>
                        </t>
                    </section>
                </section>
                <section title="Payload Block">
                    <t>Each InnerMessageBlock containing routing information SHOULD contain at least four PayloadChunks.</t>
                </section>
            </section>
        </section>

        <section title="General notes">
            <t>
                The MessageVortex protocol is a modular protocol. It allows using different encryption algorithms. For operation, a Vortex node SHOULD always support at least two completely different (i.e. relying on two different mathematical problems) types of algorithms, paddings, or modes.
            </t>
            <section title="Supported Symmetric Ciphers">
                <t>
                    A node MUST support the following symmetric ciphers:
                    <list style="symbols">
                        <t>AES128 (see <xref target="FIPS-AES"/> for AES implementation details)</t>
                        <t>AES256</t>
                        <t>CAMELLIA128 (see <xref target="RFC3657"/> chapter 3 for Camellia implementation details)</t>
                        <t>CAMELLIA256</t>
                    </list>
                    A node SHOULD support any standardized, bigger key size than the smallest key.
                </t>
                <t>A node MAY support Twofish ciphers (see <xref target="TWOFISH"/>).</t>
            </section>
            <section title="Supported Asymmetric Ciphers">
                <t>
                    A node MUST support the following asymmetric ciphers:
                    <list style="symbols">
                        <t>RSA (key sizes bigger or equal to 2048) (<xref target="RFC8017"/>)</t>
                        <t>ECC (named curves secp384r1, sect409k1, secp521r1) (see <xref target="SEC1"/>)</t>
                    </list>
                </t>
            </section>
            <section title="Supported MACs">
                <t>
                    A node MUST support the following Message Authentication Codes (MAC):
                    <list style="symbols">
                        <t>SHA256 (see <xref target="ISO-10118-3"/> for SHA implementation details)</t>
                        <t>RipeMD160 (see <xref target="ISO-10118-3"/> for RIPEMD implementation details)</t>
                    </list>
                </t>
                <t>
                    A node SHOULD support the following MACs:
                    <list style="symbols">
                        <t>SHA512</t>
                        <t>RipeMD256</t>
                        <t>RipeMD512</t>
                    </list>
                </t>
            </section>
            <section title="Supported Paddings">
                <t>
                    A node MUST support the following paddings specified in <xref target="RFC8017"/>:
                    <list style="symbols">
                        <t>PKCS1 (see <xref target="RFC8017"/>)</t>
                        <t>PKCS7 (see <xref target="RFC5958"/>)</t>
                    </list>
                </t>
            </section>
            <section title="Supported Modes">
                <t>
                    A node MUST support the following modes:
                    <list style="symbols">
                        <t>CBC (see <xref target="RFC1423"/>). The used IV must be of equal length as the key)</t>
                        <t>EAX (see <xref target="EAX"/>)</t>
                        <t>GCM (see <xref target="RFC5288"/>)</t>
                        <t>NONE (only used in special cases. See <xref target="security"/>)</t>
                    </list>
                    A node SHOULD NOT use the following modes:
                    <list style="symbols">
                        <t>NONE (Except as stated when using the addRedundancy function</t>
                        <t>ECB</t>
                    </list>
                </t>
                <t>
                    A node SHOULD support the following modes:
                    <list style="symbols">
                        <t>CTR (<xref target="RFC3686"/>)</t>
                        <t>CCM (<xref target="RFC3610"/>)</t>
                        <t>OCB (<xref target="RFC7253"/>)</t>
                        <t>OFB (<xref target="MODES"/>)</t>
                    </list>
                </t>
            </section>
        </section>

        <section anchor="blending" title="Blending">
            <t>
                Each node supports a fixed set of blending capabilities. They may be different for incoming and outgoing messages.
            </t>
            <t>
                The following sections describe the blending mechanism. There are currently two blending layers specified. One layer specification for the simple mail transfer protocol (SMTP; See <xref target="RFC5321"/>) and one for the Extensible Messaging and Presence Protocol (XMPP; See <xref target="RFC6120"/>).
            </t>
            <section anchor="blending_general" title="Blending in Attachments">
                <t>
                    There are two types of blending supported when using attachments.
                    <list style="symbols">
                        <t>Plain binary encoding with offset (PLAIN)</t>
                        <t>Embedding with F5 in an image (F5)</t>
                    </list>
                </t>
                 <t>
                    A node MUST support PLAIN blending for reasons of interoperability. A node MAY support blending using F5.
                </t>
                <section anchor="blending_general_plain" title="PLAIN embedding into attachments">
                    <t>
                        A blending layer embeds a VortexMessage in a carrier file with an offset for PLAIN blending. For replacing a file start, a node MUST use the offset 0. The routing node MUST choose the payload file for the message. A routing node SHOULD use a credible payload type (e.g., MIME type) with high entropy. It furthermore SHOULD prefix a valid header structure to avoid easy detection of the Vortex message. A routing node SHOULD use a valid footer, if any, to a payload file to improve blending.
                    </t>
                    <t>
                        A node SHOULD offer at least one PLAIN blending method for incoming Vortex messages. A node may offer multiple offsets for incoming Vortex messages.
                    </t>
                </section>
                <section anchor="blending_general_F5" title="F5 embedding into attachments">
                    <t>
                        For F5, a blending layer embeds a VortexMessage into a jpeg file according to <xref target="F5"/>. The password for blending may be publicly known. A routing node MAY advertise multiple passwords. The use of F5 adds roughly a tenfold of transfer volume to the message. A routing block building node SHOULD only use F5 blending where appropriate.
                    </t>
                </section>
            </section>
            <section anchor="blending_smtp" title="Blending into an SMTP layer">
                <t>
                    Email messages containing messages MUST be encoded with Multipurpose Internet Mail Extensions (MIME) as specified in <xref target="RFC2045"/>. All nodes MUST support BASE64 encoding. A node MUST test all sections of a MIME message for the presence of a VortexMessage.
                </t>
                <t>
                    A vortex message is present if a block containing the peer key at the known offset of any MIME part decodes correctly.
                </t>
                <t>
                    A node SHOULD support SMTP blending for sending and receiving. For sending SMTP as specified in <xref target="RFC5321"/> must be used. TLS layers MUST always be applied when obtaining messages using POP3 (as specified in <xref target="RFC1939"/> and <xref target="RFC2595"/>) or IMAP (as specified in <xref target="RFC3501"/>). Any SMTP connection MUST employ a TLS encryption when passing any credentials.
                </t>
            </section>
            <section anchor="blending_xmpp" title="Blending into an XMPP layer">
                <t>For interoperability, an implementation SHOULD provide XMPP blending.</t>
                <t>
                  Blending into XMPP traffic is done using the <xref target="XEP-0234"/> extension of the XMPP protocol.
                </t>
                <t>
                  PLAIN and F5 blending is acceptable for this transport layer.
                </t>
            </section>
        </section>

        <section anchor="routing" title="Routing">
            <section anchor="routing_message" title="Vortex Message Processing">
                <section anchor="routing_incoming" title="Processing of incoming Vortex Messages">
                    <t>
                        An incoming message is considered unauthenticated at first. A node should consider a VortexMessage as authenticated as soon as the ephemeral identity is known and is not temporary.
                    </t>
                    <t>
                        For an unauthenticated message the following rules apply:
                        <list style="symbols">
                            <t>A node MUST ignore all Routing blocks.</t>
                            <t>A node MUST ignore all Payload blocks.</t>
                            <t>A node SHOULD accept identity creation requests in unauthenticated messages.</t>
                            <t>A node MUST ignore any other header request except identity creation requests.</t>
                            <t>A node MUST ignore all identity creation requests which belong to an already existing identity.</t>
                        </list>
                    </t>
                    <t>
                        A message is considered authenticated as soon as the identity used in the header block is known and not temporary. A node MUST NOT treat a message as authenticated if the specified maximum number of replays have been reached. For authenticated messages the following rules apply:
                        <list style="symbols">
                            <t>A node MUST ignore identity creation requests.</t>
                            <t>A node MUST replace the current reply block with the reply block provided in the routing block (if any). The node MUST keep the reply block if no reply block is provided.</t>
                            <t>A node SHOULD process all header requests.</t>
                            <t>A node SHOULD add all routing blocks to the workspace.</t>
                            <t>A node SHOULD add all payload blocks to the workspace.</t>
                        </list>
                        A routing node MUST decrement the message quota by one if a received message is authenticated and contains at least one payload block. If a message is identified as duplicate acording to the reply protection, a node MUST NOT decrement the message quota.
                    </t>
                </section>
                <section anchor="routing_workspace" title="Processing of Routing Blocks in Workspace">
                    <t>
                        A routing workspace consists of the following items:
                        <list style="symbols">
                            <t>The identity linked to it (This determines the lifetime of the workspace).</t>
                            <t>The routing combos (RoutingCombo) linked to it.</t>
                            <t>A payload chunk space. Multiple subspaces are available within this space:
                                <list style="symbols">
                                    <t>ID 0 represents a message to be embedded (when reading) or a message to be extracted to the user (when written).</t>
                                    <t>ID 1 to ID maxPayloadBlocks represents the payload chunk slots in the target message.</t>
                                    <t>All blocks between ID maxPayloadBlocks+1 to ID 32767 belong to a temporary routing block specific space.</t>
                                    <t>All blocks between ID 32768 to ID 65535 belong to a shared space available to all operations of this identity.</t>
                                </list>
                            </t>
                        </list>
                    </t>
                    <t>
                        The accounting layer typically triggers processing. It represents either a cleanup action or a routing event. A cleanup event deletes the following information from all workspaces:
                        <list style="symbols">
                            <t>All processed routing combos.</t>
                            <t>All routing combos with  expired usagePeriod.</t>
                            <t>All payload chunks when exceeded their maxProcess time.</t>
                            <t>All expired objects.</t>
                            <t>All expired puzzles.</t>
                            <t>All expired identities.</t>
                            <t>All expired replay protections.</t>
                        </list>
                        Note that maxProcessTime reflects the number of seconds since the arrival of the last octet of the message at the transport layer facility. A node SHOULD NOT take additional processing time (e.g., for anti-UBE or anti-virus) into account.
                    </t>
                    <t>
                        The accounting layer triggers routing events. The trigger occurs at least minProcessTime after the last octet of the message arrived at the routing layer. A node SHOULD choose the latest possible moment in such a way that the peer node receives the last octet of the assembled message before maxProcessTime is reached. The calculation of the last point in time where a message may be set SHOULD always assume that the target node is working. A sending node SHOULD choose the time within these bounds randomly. An accounting layer MAY trigger multiple routing combos in bulk to further obfuscate identity of a single transport message.
                    </t>
                    <t>
                        First, the processing node escapes the payload chunk at ID 0 if needed (non-special block starting with a backslash). Next, it executes all processing instructions of a routing combo in the sequence specified. If an instruction fails, the block at the target ID of the operation remains unchanged. The routing layer proceeds with the subsequent processing instructions, ignoring the error. For a detailed description of the operations see <xref target="routing_operations"/>. If a node succeeds in building at least one payload chunk, a VortexMessage is composed and passed to the blending layer.
                    </t>
                </section>
                <section anchor="routing_outgoing" title="Processing of Outgoing MessageVortex Messages">
                    <t>
                        The blending layer MUST then compose a transport layer message according to the specification provided in the routing combo. It SHOULD choose any decoy message or steganographic carrier in such a way that the dead parrot syndrome as specified in <xref target="DeadParrot"/> is avoided.
                    </t>
                </section>
            </section>
            <section anchor="routing_header" title="Header Requests">
                <t>
                    Header requests are control requests for the anonymization system. Messages with requests or replies only MUST NOT affect any quota.
                </t>
                <section anchor="routing_header_eid" title="Request New Ephemeral Identity">
                    <t>
                        Requesting a new ephemeral identity is done by sending a message containing a header block with the new identity and an identity creation request (HeaderRequestIdentity) to a node. The node MAY send an error block (see <xref target="routing_special_error"/>) if rejecting the request.
                    </t>
                    <t>
                        If a node accepts an identity creation request, it MUST send a reply. To accept a request without a requirement, an accepting node MUST send back a special block containing "no error". To accept a block with a requirement, an accepting node MUST send a special block containing a requirement block.
                    </t>
                </section>
                <section anchor="routing_header_req_msg_quota" title="Request Message Quota">
                    <t>
                        Any valid ephemeral identity may request to raise the current message quota to a specific value at any time. The request MUST include a reply block in the header. The request may contain other parts. If a requested value is lower than the current quota, the node SHOULD NOT refuse the quota request and SHOULD send a "No Error" status.
                    </t>
                    <t>
                        A node SHOULD reply to a HeaderRequestIncreaseMessageQuota request (see <xref target="asn_one"/>) of a valid ephemeral identity. The reply MUST include a requirement, an error message or a "No Error" status message.
                    </t>
                </section>
                <section anchor="routing_header_inc_msg_quota" title="Request Increase of Message Quota">
                    <t>
                        A node may request to increase the current message quota. The increase is requested by sending a HeaderRequestIncreaseMessageQuota request to the routing node. The value specified within the node is the new quota. HeaderRequestIncreaseMessageQuota requests MUST include a reply block. A node SHOULD NOT use a previously sent MURB to reply.
                    </t>
                    <t>
                        If the requested quota is higher than the current quota, then the node SHOULD send a "no error" reply. If the requested quota is not accepted, the node SHOULD send a requestedQuotaOutOfBand reply.
                    </t>
                    <t>
                        A node accepting the request MUST send a RequirementBlock or a "no error block".
                    </t>
                </section>
                <section anchor="routing_header_req_trans_quota" title="Request Transfer Quota">
                    <t>
                        Any valid ephemeral identity may request to raise the current transfer quota to a specific value at any time. The request MUST include a reply block in the header. The request may contain other parts. If a requested value is lower than the current quota, the node SHOULD NOT refuse the quota request and SHOULD send a "No Error" status.
                    </t>
                    <t>
                        A node SHOULD reply to a HeaderRequestIncreaseTransferQuota request (see <xref target="asn_one"/>) of a valid ephemeral identity. The reply MUST include a requirement, an error message, or a "No Error" status message.
                    </t>
                </section>
                <section anchor="routing_header_qry_quota" title="Query Quota">
                    <t>
                        Any valid ephemeral identity may request the current message and transfer quota. The request MUST include a reply block in the header. The request may contain other parts.
                    </t>
                    <t>
                        A node MUST reply to a HeaderRequestQueryQuota request (see <xref target="asn_one"/>). The reply MUST include the current message quota and the current message transfer quota. The reply to this request MUST NOT include a requirement.
                    </t>
                </section>
                <section anchor="routing_header_req_cap" title="Request Capabilities">
                    <t>
                        Any node MAY request the capabilities of another node. The capabilities include all information necessary to create a parseable VortexMessage. Any node SHOULD reply to any encrypted HeaderRequestCapability.
                    </t>
                </section>
                <section anchor="routing_header_req_nodes" title="Request Nodes">
                    <t>
                        A node may ask another node for a list of routing node addresses and keys. This request may be used to bootstrap a new node and to add routing nodes increasing the anonymization of a node. The receiving node of such a request SHOULD reply with a requirement (e.g., RequirementPuzzleRequired).
                    </t>
                    <t>
                        A node SHOULD reply to a HeaderRequest request (see <xref target="asn_one"/>) of a valid ephemeral identity. The reply MUST include a requirement, an error message or a "No Error" status message.
                    </t>
                </section>
                <section anchor="routing_header_req_identity_replace" title="Request Identity Replace">
                    <t>
                        This request allows a receiving node to replace an identity with the identity provided in the message. This request is required if an adversary managed to deny the usage of a node (e.g., by deleting the corresponding transport account). Any sending node may recover from such an attack by sending a validly authenticated message to another identity providing the new transport and key details.
                    </t>
                    <t>
                        A node SHOULD reply to a such a request of a valid known identity. The reply MUST include an error message or a "No Error" status message.
                    </t>
                </section>
            </section>
            <section anchor="routing_special" title="Special Blocks">
                <t>
                    Special blocks are payload messages. They reflect messages from one node to another and are not visible to the user. A special block starts with the character sequence '\special' (or 5Ch 73h 70h 65h 63h 69h 61h 6Ch) followed by a DER encoded special block (SpecialBlock). Any non-special message decoding to ID 0 in a workspace starting with a backslash (5Ch) MUST escape all backslashes within the payload chunk with an additional backslash.
                </t>
                <section anchor="routing_special_error" title="Error Block">
                    <t>
                        An error block may be sent as a reply where specified as a payload. The error block is embedded in a special block and sent with any provided reply block. Error messages SHOULD contain the serial number of the offending header block and MAY contain a human-readable text providing additional messages about the error.
                    </t>
                </section>
                <section anchor="routing_special_requirement" title="Requirement Block">
                    <t>
                        If a node is receiving a requirements block, it MUST assume that the request block has been accepted, has not been processed yet, and will be processed if the contained requirement is met. A node MUST process a request as soon as the requirement is fulfilled. A node MUST resend the request as soon as the requirement is met.
                    </t>
                    <t>
                        A node MAY reject a request, accept a request without a requirement, accept a request upon payment (RequirementPaymentRequired), or accept a request upon solving a proof of work puzzle (RequirementPuzzleRequired).
                    </t>
                    <section anchor="routing_spezial_requirement_puzzle" title="Puzzle Requirement">
                        <t>
                            If a node requests a puzzle, it MUST send a RequirementPuzzleRequired block. The puzzle requirement is solved, if the node receiving the puzzle is replying with a header block containing the puzzle block and the hash of the encoded block starts with the bit sequence mentioned in the puzzle within the period specified in the field 'valid'.
                        </t>
                        <t>
                            To solve a puzzle posed by a node a Vortex Message needs to be sent to the requesting node. This Vortex Message MUST contain a header block which includes the puzzle block and MUST have a MAC fingerprint starting with the bit sequence as specified in the challenge. A node calculates the MAC from the unencrypted DER encoded HeaderBlock with the algorithm specified by the node. To meet this requirement, a node adds a proofOfWork field to the HeaderBlock.
                        </t>
                    </section>
                    <section anchor="routing_spezial_requirement_payment" title="Payment Requirement">
                        <t>
                            If a node requests a payment, it MUST send a RequirementPaymentRequired block. As soon as the requested fee is paid and confirmed, the requesting node MUST send a "No Error" status message. The usage period 'valid' describes the period in which the payment may be carried out. A node MUST accept the payment if carried out within the 'valid' period but confirmed later. A node SHOULD return allunsolicited payments to the sending address.
                        </t>
                    </section>
                </section>
            </section>
            <section anchor="routing_operations" title="Routing Operations">
                <t>
                    Routing operations are contained in a routing block and processed either on arrival on a message or when a compiling new message. All Operations are reversible. No Operation is available for generating decoy traffic. For decoy traffic, either encryption of an unpadded block may be used, or the addRedundancy operation.
                </t>
                <t>
                    All payload chunk blocks inherit the validity time from the message routing combos (arrival time + max(maxProcessTime)).
                </t>
                <t>
                    When applying an operation to a source block, the resulting target block inherits the expiry of the of the source block. When having multiple different expiry times, the expiry the furthest in the future will be applied to the target block. If the operation fails, the target expiry remains unchanged.
                </t>
                <section anchor="routing_operations_mapping" title="Mapping Operation">
                    <t>
                        A mapping operation is a straightforward operation mainly used in inOperations of a routing block to map the routing block specific blocks to a permanent workspace.
                    </t>
                </section>
                <section anchor="routing_operations_mergesplit" title="Split and Merge Operations">
                    <t>
                        The split and merge operations allow splitting and recombining message chunks. A node MUST adhere to these constraints:
                        <list style="symbols">
                            <t>The operation must be applied at an absolute (measuring in bytes) or relative (measured as a float value in the range 0&gt;value&gt;100) position.</t>
                            <t>All calculations must be done according to <xref target="IEEE754">IEEE 754</xref> and in 64 Bit precision.</t>
                            <t>If a relative value is a non-integer result, a floor operation (cutting off all non-integer parts) determines the number of bytes.</t>
                            <t>If an absolute value is negative, the size reflected applies to the number of bytes counted from the end of the message chunk.</t>
                            <t>If an absolute value is bigger than the number of bytes in a block, all bytes are mapped to the respective target block, and the other target block becomes a zero byte sized block.</t>
                        </list>
                    </t>
                    <t>
                        An operation MUST fail if relative values are equal to, or below zero. An operation MUST fail if a relative value is equal to or above 100. All floating point operations must be carried out according to <xref target="IEEE754"/> and in 64-bit precision.
                    </t>
                </section>
                <section anchor="routing_operations_crypt" title="Encrypt and Decrypt Operations">
                    <t>
                        Encryption and decryption are executed according to the standards mentioned before. An encryption operation encrypts a block symmetrically and places the result in the target block. The parameters MUST contain required parameters such as IV, padding, or cipher modes. An encryption operation without a valid parameter set MUST fail.
                    </t>
                </section>
                <section anchor="routing_operations_redundancy" title="Add and Remove Redundancy Operations">
                    <t>
                        The addRedundancy and removeRedundancy operations are the core operations of the protocol. They may be used to split messages and distribute message content across multiple routing nodes. The operation is split into three steps.
                        <list style="numbers">
                            <t>Pad the input block to a multiple of the key block size in the resulting output blocks.</t>
                            <t>Apply a Vandermonde matrix with the given sizes.</t>
                            <t>Encrypt each resulting block with a separate key.</t>
                        </list>
                        The following sections describe the order of the operations in an addRedundancy operation. For a removeRedundancy operation invert the functions and order.
                    </t>
                    <section anchor="routing_operations_redundancy_padding" title="Padding Operation">
                        <t>
                            First, the length of all output blocks including redundancy is calculated. This is done by L=roof((&lt;input block size in bytes&gt;+4)/&lt;encryption block size in bytes&gt;)*&lt;block size in bytes&gt;. The block is prepended with a 32-bit length indicator in bytes at the beginning (little-endian). This length indicator i is calculated by i=&lt;input block size in bytes&gt;*randominteger()*L. The rest of the input block up to length L is padded with random data. If GF(16) is applied, numbers are treated as little-endian representations.
                        </t>
                        <t>
                            For padding removal, first, the padding i at the start is removed as a little-endian integer. Then, the length of the output block is calculated by applying &lt;output block size in bytes&gt;=i mod &lt;input block size in bytes&gt;
                        </t>
                        <t>
                           This padding guarantees that each resulting block is as big as the subsequent encryption operation and does not require any further padding.
                        </t>
                    </section>
                    <section anchor="routing_operations_redundancy_matrix" title="Apply Matrix">
                        <t>
                            Next, the input block is organized in a data matrix D of dimensions inrows,incols where incols=(&lt;number of data blocks&gt;-&lt;number of redundancy blocks&gt;) and inrows=L/(&lt;number of data blocks&gt;-&lt;number of redundancy blocks&gt;). The input block data is distributed in this matrix first across, then down.
                        </t>
                        <t>
                            Next, we multiply the data matrix D by a Vandermonde matrix V. The V matrix has the number of rows equal to the incols calculated, and columns are equal to the &lt;number of data blocks&gt;. The content of the matrix is formed by  v(i,j)=pow(i,j), whereas i reflects the row number starting at 0, and j reflects the column number starting at 0. Please note that calculations noted here have to be carried out in the GF noted in the respective operation to be successful. The operation results in a matrix A.
                        </t>
                    </section>
                    <section anchor="routing_operations_redundancy_encrypt" title="Encrypt Target Block">
                        <t>
                            Each row vector of A is a new data block which is then encrypted with the corresponding encryption key noted in keys of the addRedundancyOperation. If there are not enough keys available, the keys used for encryption are reused from the beginning after the last key has been used. A routing block builder SHOULD provide enough keys so that all target blocks may be encrypted with a unique key. All encryptions SHOULD NOT use padding.
                        </t>
                    </section>
                </section>
            </section>
            <section anchor="routing_processing" title="Processing of Vortex Messages">
                <t>
                    The accounting layer triggers processing according to information contained in a routing block in the workspace. All operations MUST be executed in the sequence provided in the routing block. Any failing operation must leave the result block unmodified.
                </t>
                <t>
                    All workspace blocks resulting in IDs 1 to maxPayloadBlock are then added to the message and passed to the blending layer with appropriate instructions.
                </t>
            </section>
        </section>

        <section anchor="accounting" title="Accounting">
            <section anchor="accounting_operations" title="Accounting Operations">
                <t>The accounting layer has two major kinds of operations:
                    <list style="symbols">
                        <t>
                            Time-based operations (cleanup jobs and initiation of routing)
                        </t>
                        <t>
                            Routing triggered operations (updating quotas, authorizing operations, and pickup of incoming messages)
                        </t>
                    </list>
                    Implementations MUST provide sufficient locking mechanisms to guarantee the integrity of accounting information and workspace at any time.
                </t>
                <section anchor="accounting_timed_gc" title="Time-Based Garbage Collection">
                    <t>
                        The accounting layer SHOULD keep a list of expiry times. As soon as an entry (e.g., payload block, or identity) expires, the respective structure should be removed from the workspace. An implementation MAY choose to remove expired items periodically or when encountering them during normal operation.
                    </t>
                </section>
                <section anchor="accounting_timed_routing" title="Time-Based Routing Initiation">
                    <t>
                        The accounting layer MAY keep a list of any time a routing block is activated. For improved privacy, the accounting layer should use a slotted model where, whenever possible, multiple routing blocks are handled in the same period of time, and the requests to the blending layers are mixed between the transactions.
                    </t>
                </section>
                <section anchor="accounting_timed_quota" title="Routing Based Quota Updates">
                    <t>
                        A node MUST update quotas on the respective operations. It MUST decrease message quota before processing routing blocks in the workspace. A node MUST decrease the message quota after the processing of any header requests.
                    </t>
                </section>
                <section anchor="accounting_routhing_auth" title="Routing Based Authorization">
                    <t>
                        The transfer quota MUST be checked and decreased by the number of data bytes in the payload chunks after an outgoing message is processed and fully assembled. The message quota MUST be decreased by one on each routing block triggering the assembly of an outgoing message.
                    </t>
                </section>
                <section anchor="accounting_create_identity" title="Ephemeral Identity Creation">
                    <t>
                        Any packet may request the creation of an ephemeral identity. A node SHOULD NOT accept such a request without a costly requirement. The request includes a lifetime of the ephemeral identity. The costs for creating the ephemeral identity SHOULD raise if a longer lifetime is requested.
                    </t>
                </section>
            </section>
        </section>

        <section anchor="Acknowledgments" title="Acknowledgments">
            <t>Thanks go to my family which did support me with patience and countless hours and to Mark Zeman for his feedback challenging my thoughts and peace.</t>
        </section>

        <section anchor="IANA" title="IANA Considerations">
            <t>This memo includes no request to IANA.</t>

            <t>Additional encryption algorithms, paddings, modes, blending layers, or puzzles MUST be added by writing an extension to this or a subsequent RFC. For testing purposes, IDs above 1,000,000 should be used.</t>
        </section>

        <section anchor="security" title="Security Considerations">
            <t>
                The MessageVortex protocol may be understood more as a toolset than a fixed product. Depending on the usage of the toolset anonymity and security are affected. For a detailed analysis see <xref target="MVAnalysis"/>.
            </t>
            <t>
                The primary goals for security within this protocol did rely on the following focus areas:
                <list style="symbols">
                    <t>Confidentiality</t>
                    <t>Integrity</t>
                    <t>Availability</t>
                    <t>Anonymity
                        <list style="symbols">
                            <t>3rd party anonymity</t>
                            <t>sender anonymity</t>
                            <t>receiver anonymity</t>
                        </list>
                    </t>
                </list>

                All these factors are affected by the usage of the protocol. The following sections provide a list of factors affecting the primary goals.
            </t>
            <t>
                The Vortex protocol does not rely on any encryption on the transport layer. Vortex messages are already encrypted. Confidentiality is not affected by the protection mechanisms of the transport layer.
            </t>
            <t>
                If a transport layer supports encryption, a Vortex node SHOULD use it to improve the privacy of the message.
            </t>
            <t>
                Anonymity is affected by the inner workings of the blending layer in many ways. A Vortex message cannot be read by anyone except the peer nodes and the routing block builder, but the presence of a vortex node message may be detected. This may be done either by detecting the typical high entropy of an encrypted file, broken structures of a carrier file, a meaningless content of a carrier file, or the contextless communication of the transport layer with its peer partner. A blending layer SHOULD minimize the possibility of easy detection by minimizing these effects.
             </t>
             <t>
                A blending layer SHOULD use carrier files with high compression or encryption. Carrier files SHOULD NOT have inner structures so that the payload is comparable to valid content. To achieve undetectability by a human reviewer, a routing block builder should use F5 blending instead of PLAIN blending. This, however, increases the protocol overhead roughly by a tenfold.
             </t>
             <t>
                 The two layers 'routing' and 'accounting' have the deepest insight into a Vortex message's inner working. They know the immediate peer sender and the peer recipients of all payload chunks. As decoy traffic is generated by combining chunks and applying redundancy calculations upon them, a node can never know whether a malfunction (e.g., when doing a recovery calculation) was intended or not. Therefore a node is unable to tell a failed transaction apart from a terminated transaction. It furthermore cannot tell content apart from decoy traffic.
             </t>
             <t>
                A routing block builder SHOULD follow the following rules in order not to compromise a Vortex message's anonymity:
                <list style="symbols">
                    <t>All operations applied SHOULD be credibly involved in a message transfer.</t>
                    <t>There should always be a sufficient subset of the result of an addRedundancy operation sent to peers to allow recovery of the data built.</t>
                    <t>The anonymity set of a message should be sufficiently large to avoid legal prosecution of all jurisdictional entities involved. It has to be large enough to do so even if a certain amount of the anonymity set cooperates with an adversary.</t>
                    <t>Encryption and decryption SHOULD follow whenever possible normal usage. Avoid encrypting a block on a node with one key and decrypting it with a different key on the same or an adjacent node.</t>
                    <t>Traffic peaks SHOULD be uniformly distributed within the whole anonymity set.</t>
                    <t>A routing block SHOULD be used for a limited number of messages. If used as a message block for the node itself it should be used only once. A block builder SHOULD use the HeaderRequestReplaceIdentity block to update reply routing blocks on a regular base. Implementers should always keep in mind that the same routing block is identifiable as such by its structure.</t>
                </list>
             </t>
             <t>
                An active adversary cannot use blocks from other routing block builders for his purposes. He may falsify the result by injecting wrong message chunks or by not sending a message. Such message disruptions may be detected by intentionally routing some information to the routing block builders' node. If the Vortex message does not carry the information expected the node may safely assume that one of the involved nodes is misbehaving. A block building node MAY calculate reputation for involved nodes over time. A block building node MAY build redundancy paths into a routing block to withstand such malicious nodes.
            </t>
            <t>
                Receiver anonymity is in danger if the handling of message header and content is not done with care. An attacker might send a bugged message (e.g., with a DKIM or DMARC header) to deanonymize a recipient. Great care has to be taken when handling any other than local references when processing, verifying, or rendering a message.
            </t>
        </section>
    </middle>

    <!--  *****BACK MATTER ***** -->

    <back>
        <references title="Normative References">
            <!-- Use of words -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?>
            <!-- Camelia -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3657.xml"?>
            <!-- SHA (no longer needed -->
            <!--<?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6234.xml"?>-->
            <!-- PKCS#1 -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.8017.xml"?>
            <!-- PKCS#8 -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5958.xml"?>
            <!-- GCM -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5288.xml"?>
            <!-- CTR -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3686.xml"?>
            <!-- CCM -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3610.xml"?>
            <!-- OCB -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.7253.xml"?>
            <!-- CBC -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.1423.xml"?>
            <!-- ABNF -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5234.xml"?>


            <reference anchor="ISO-10118-3">
                <front>
                    <title>ISO/IEC 10118-3:2004 -- Information technology -- Security techniques -- Hash-functions -- Part 3: Dedicated hash-functions</title>
                    <author>
                        <organization>International Organization for Standardization</organization>
                    </author>
                    <date year="2004" month="3"/>
                </front>
            </reference>

            <reference anchor="CCITT.X208.1988">
                <front>
                    <title>Specification of Abstract Syntax Notation One (ASN.1)</title>
                    <author>
                        <organization>International Telephone and Telegraph Consultative Committee</organization>
                </author>
                    <date year="1998" month="11"/>
                </front>
                <seriesInfo name="CCITT Recommendation" value="X.208"/>
            </reference>

            <reference anchor="CCITT.X680.2002">
                <front>
                    <title>Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
                    <author>
                        <organization>International Telephone and Telegraph Consultative Committee</organization>
                    </author>
                    <date year="2002" month="11"/>
                </front>
                <!--<seriesInfo name="CCITT Recommendation" value="X.680"/>-->
            </reference>

            <reference anchor="XEP-0234" target="https://xmpp.org/extensions/xep-0234.html">
                <front>
                    <title>XEP-0234: Jingle File Transfer</title>
                    <author surname="Peter" initials="S.A."/>
                    <author surname="Stout" initials="L."/>
                    <date year="2017" month="08" day="24"/>
                </front>
            </reference>

            <reference anchor="F5">
                <front>
                    <title>F5 - A Steganographic Algorithm - High Capacity Despite Better Steganalysis</title>
                    <author initials="A." surname="Westfeld">
                        <organization>TU Dresden</organization>
                    </author>
                    <date year="2001" month="10" day="24"/>
                </front>
            </reference>

            <reference anchor="TWOFISH">
                <front>
                    <title>The Twofish Encryptions Algorithm: A 128-Bit Block Cipher, 1st Edition</title>
                    <author initials="B." surname="Schneier"/>
                    <date year="1999" month="03"/>
                </front>
            </reference>

            <reference anchor="SEC1">
                <front>
                    <title>SEC 1: Elliptic Curve Cryptography</title>
                    <author>
                        <organization>Certicom Research</organization>
                    </author>
                    <date year="2009" month="05" day="21"/>
                </front>
            </reference>

            <reference anchor="FIPS-AES">
                <front>
                    <title>Specification for the ADVANCED ENCRYPTION STANDARD
                        (AES)</title>
                    <author>
                        <organization>Federal Information Processing Standard (FIPS)</organization>
                    </author>
                    <!--<seriesInfo name="Publication" value="197"/>-->
                    <date year="2011" month="11" />
                </front>
            </reference>

            <reference anchor="EAX">
                <front>
                    <title>The EAX mode of operation</title>
                    <author initials="M." surname="Bellare"/>
                    <author initials="P." surname="Rogaway"/>
                    <author initials="D." surname="Wagner"/>
                    <!--<seriesInfo name="LNCS" value="3017"/>-->
                    <date year="2011"/>
                </front>
            </reference>

            <reference anchor="MODES">
                <front>
                    <title>Recommendation for Block Cipher Modes of Operation: Methods and Techniques</title>
                    <author>
                        <organization>National Institute for Standards and Technology (NIST)</organization>
                    </author>
                    <!--<seriesInfo name="NIST Special Publication" value="800-38A"/>-->
                    <date year="2001" month="12" />
                </front>
            </reference>

            <reference anchor="IEEE754">
                <front>
                    <title>754-2008 - IEEE Standard for Floating-Point Arithmetic</title>
                    <author>
                        <organization>IEEE</organization>
                    </author>
                    <date year="2008" month="08" day="29"/>
                </front>
            </reference>

        </references>

        <references title="Informative References">

            <!-- MIME -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml"?>
            <!-- XMPP -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6120.xml"?>
            <!-- SMTP -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5321.xml"?>
            <!-- IMAP -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3501.xml"?>
            <!-- POP3 -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.1939.xml"?>
            <!-- POP3 STARTTLS -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2595.xml"?>
            <!-- XMPP Adress -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.7622.xml"?>

            <reference anchor="MVAnalysis" target="https://messagevortex.net/devel/messageVortex.pdf">
                <front>
                    <title>MessageVortex</title>
                    <author initials="M." surname="Gwerder"/>
                    <date year="2018" />
                </front>
            </reference>

            <reference anchor="DeadParrot" target="https://people.cs.umass.edu/~amir/papers/parrot.pdf">
                <front>
                    <title>The Parrot is Dead: Observing Unobservable Network Communications</title>
                    <author initials="A." surname="Houmansadr"/>
                    <author initials="C." surname="Burbaker"/>
                    <author initials="V." surname="Shmatikov"/>
                    <date year="2013" />
                </front>
            </reference>

            <reference anchor="KAnon">
                <front>
                    <title>k-Anonymous Message Transmission</title>
                    <author initials="L." surname="Ahn">
                        <organization>Carnegie Mellon University</organization>
                    </author>
                    <author initials="A." surname="Bortz">
                        <organization>Carnegie Mellon University</organization>
                    </author>
                    <author initials="N.J." surname="Hopper">
                        <organization>Carnegie Mellon University</organization>
                    </author>
                    <date year="2003" />
                </front>
            </reference>

        </references>

        <section anchor="asn_one" title="The ASN.1 schema for Vortex messages">
            <t>
                The following sections contain the ASN.1 modules specifying the MessageVortex Protocol
            </t>
            <section  anchor="asnOne_schema" title="The main VortexMessageBlocks">
                <t>
                    <figure>
                        <artwork src="asn/MessageVortex-Schema.asn"><![CDATA[MessageVortex-Schema DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  EXPORTS PrefixBlock, InnerMessageBlock, RoutingBlock,
          maxID;
  IMPORTS SymmetricKey, AsymmetricKey, MacAlgorithmSpec, CipherSpec
                FROM MessageVortex-Ciphers
          HeaderRequest
                FROM MessageVortex-Requests
          PayloadOperation
                FROM MessageVortex-Operations

          UsagePeriod, BlendingSpec
                FROM MessageVortex-Helpers;

  --***************************************************************
  -- Constant definitions
  --***************************************************************

  -- maximum serial number
  maxSerial                 INTEGER ::= 4294967295
  -- maximum number of administrative requests
  maxNumberOfRequests       INTEGER ::= 8
  -- maximum number of seconds which the message might be delayed
  -- in the local queue (starting from startOffset)
  maxDurationOfProcessing   INTEGER ::= 86400
  -- maximum id of an operation
  maxID                     INTEGER ::= 32767
  -- maximum number of routing blocks in a message
  maxRoutingBlocks          INTEGER ::= 127
  -- maximum number a block may be replayed
  maxNumberOfReplays        INTEGER ::= 127
  -- maximum number of payload chunks in a message
  maxPayloadBlocks          INTEGER ::= 127
  -- maximum number of seconds a proof of non revocation may be old
  maxTimeCachedProof        INTEGER ::= 86400
  -- The maximum ID of the workspace
  maxWorkspaceId            INTEGER ::= 65535
  -- The maximum number of assembly instructions per combo
  maxAssemblyInstructions   INTEGER ::= 255

  --***************************************************************
  -- Block Definitions
  --***************************************************************
  PrefixBlock ::= SEQUENCE {
    forwardsecret   ChainSecret,
    key             SymmetricKey,
	version			INTEGER OPTIONAL
  }

  HeaderBlock ::= SEQUENCE {
    -- Public key of the identity representing this transmission
    identityKey        AsymmetricKey,
    -- serial identifying this block
    serial             INTEGER (0..maxSerial),
    -- number of times this block may be replayed (Tuple is
    -- identityKey, serial while UsagePeriod of block)
    maxReplays         INTEGER (0..maxNumberOfReplays),
    -- subsequent Blocks are not processed before valid time.
    -- Host may reject too long retention. Recomended validity
    -- support >=1Mt.
    valid              UsagePeriod,
    -- represents the chained secret which has to be found in
    -- subsequent blocks
    -- prevents reassembly attack
    forwardSecret       ChainSecret,
    --  contains the MAC-Algorithm used for signing
    signAlgorithm       MacAlgorithmSpec,
    -- contains administrative requests such as quota requests
    requests            SEQUENCE (SIZE (0..maxNumberOfRequests))
                        OF HeaderRequest ,
    -- Reply Block for the requests
    requestReplyBlock   RoutingCombo,
    -- padding and identitifier required to solve the cryptopuzzle
    identifier  [12201] PuzzleIdentifier OPTIONAL,
    -- This is for solving crypto puzzles
    proofOfWork [12202] OCTET STRING OPTIONAL
  }

  InnerMessageBlock ::= SEQUENCE {
    padding   OCTET STRING,
    prefix    CHOICE {
        plain           [11011] PrefixBlock,
        -- contains prefix encrypted with receivers public key
        encrypted       [11012] OCTET STRING
    },
    identity  CHOICE  {
      -- debug/internal use only
      plain     [11021] HeaderBlock,
      -- contains encrypted identity block
      encyrpted [11022] OCTET STRING
    },
    -- contains signature of Identity [as stored in
    -- HeaderBlock; signed unencrypted HeaderBlock without Tag]
    identitySignature OCTET STRING,
    -- contains routing information (next hop) for the payloads
    routing     CHOICE {
      plain     [11031] RoutingBlock,
      -- contains encrypted routing block
      encyrpted [11032] OCTET STRING
    },
    -- contains the actual payload
    payload     SEQUENCE (SIZE (0..maxPayloadBlocks))
                OF OCTET STRING
  }

  RoutingBlock ::= SEQUENCE {
    -- contains the prefix to be used
    routing    CHOICE {
      -- debug/internal use only
      plain             [331] SEQUENCE (SIZE (0..maxRoutingBlocks))
                              OF RoutingCombo,
      encrypted         [332] SEQUENCE (SIZE (0..maxRoutingBlocks))
                              OF OCTET STRING
    },
    -- contains the secret of the header block
    forwardSecret     ChainSecret,
    -- contains a routing block which may be used when sending
    -- error messages back to the quota owner
    -- this routing block may be cached for future use
    replyBlock [131]   SEQUENCE {
         murb           RoutingCombo,
         maxReplay      INTEGER,
         validity       UsagePeriod
    } OPTIONAL
  }

  RoutingCombo ::= SEQUENCE {
    -- contains the period when the payload should be processed
    -- Router might refuse to long queue retention
    -- Recommended support for retention >=1h
    minProcessTime INTEGER (0..maxDurationOfProcessing),
    maxProcessTime INTEGER (0..maxDurationOfProcessing),
    -- The message key to encrypt the message
    messageKey    [401] SymmetricKey OPTIONAL,
    -- contains the next recipient
    recipient     [402] BlendingSpec OPTIONAL,
    -- PrefixBlock encrypted with message key
    mPrefix       [403] OCTET STRING OPTIONAL,
    -- PrefixBlock encrypted with sender key
    cPrefix       [404] OCTET STRING OPTIONAL,
    -- HeaderBlock encrypted with sender key
    header        [405] OCTET STRING OPTIONAL,
    -- RoutingBlock encrypted with sender key
    routing       [406] OCTET STRING OPTIONAL,
    -- contains information for building messages (when used as MURB
    -- ID 0 denotes original message; ID 1-maxPayloadBlocks denotes
    -- target message; 32768-maxWorkspaceId shared workspace for all
    -- blocks of this identity)
    assembly      [407] SEQUENCE (SIZE (0..maxAssemblyInstructions))
                  OF PayloadOperation,
    validity      [408] UsagePeriod,
    -- optional - to identify the sender of a message when received
    id            [409] INTEGER OPTIONAL
  }

  PuzzleIdentifier          ::= OCTET STRING ( SIZE(0..16) )

  ChainSecret ::= INTEGER (0..4294967295)

END]]></artwork>
                    </figure>
                </t>
            </section>
            <section  anchor="asnOne_operations" title="The VortexMessage Operation Structures">
                <t>
                    <figure>
                        <artwork src="asn/MessageVortex-Operations.asn"><![CDATA[MessageVortex-Operations DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  EXPORTS PayloadOperation;
  IMPORTS maxID
                FROM MessageVortex-Schema
          SymmetricKey, AsymmetricKey, MacAlgorithmSpec, CipherSpec
                FROM MessageVortex-Ciphers
          UsagePeriod, BlendingSpec
                FROM MessageVortex-Helpers;

  -- maximum omega of the Galois field used
  maxGFSize                 INTEGER ::= 16
  -- maximum size of a message chunk
  maxChunkSize              INTEGER ::= 4294967295
  -- minimum size of a message chunk (should be -maxChunkSize)
  minChunkSize              INTEGER ::= -4294967295

  PayloadOperation ::= CHOICE {
    splitPayload    [150] SplitPayloadOperation,
    mergePayload    [160] MergePayloadOperation,
    encryptPayload  [300] EncryptPayloadOperation,
    decryptPayload  [310] DecryptPayloadOperation,
    addRedundancy   [400] AddRedundancyOperation,
    removeRedundancy[410] RemoveRedundancyOperation
  }

  PercentSizeBlock ::= SEQUENCE {
    fromPercent         INTEGER (0..100),
    toPercent           INTEGER (0..100)
  }

  AbsoluteSizeBlock ::= SEQUENCE {
    fromAbsolute        INTEGER (0..maxChunkSize),
    toAbsolute          INTEGER (minChunkSize..maxChunkSize)
    -- negative toAbsolute denominates end in absolute value
    -- specified from the end of block
  }

  SizeBlock ::= SEQUENCE{
    size CHOICE {
      percent     [15001] PercentSizeBlock,
      absolute    [15101] AbsoluteSizeBlock
    }
  }

  AddRedundancyOperation ::= SEQUENCE {
    inputId            [16000] INTEGER (0..maxID),
    dataStripes        [16001] INTEGER (1..254),
    redundancy         [16002] INTEGER (1..254),
    keys               [16003] SEQUENCE (SIZE (2..512))
                               OF SymmetricKey,
    outputId           [16004] INTEGER (1..maxID),
    gfSize             [16005] INTEGER (2..maxGFSize)
  }

  RemoveRedundancyOperation ::= SEQUENCE {
    inputId            [16000] INTEGER (0..maxID),
    dataStripes        [16001] INTEGER (1..254),
    redundancy         [16002] INTEGER (1..254),
    keys               [16003] SEQUENCE (SIZE (2..512))
                               OF SymmetricKey,
    outputId           [16004] INTEGER (1..maxID),
    gfSize             [16005] INTEGER (2..maxGFSize)
  }

  SplitPayloadOperation ::= SEQUENCE {
    originalId         INTEGER (0..maxID),
    firstSize          SizeBlock,
    newFirstId         INTEGER (1..maxID),
    newSecondId        INTEGER (1..maxID)
  }

  MergePayloadOperation ::= SEQUENCE {
    originalFirstId      INTEGER (0..maxID),
    originalSecondId     INTEGER (0..maxID),
    newId                INTEGER (1..maxID)
  }

  EncryptPayloadOperation ::= SEQUENCE {
    originalId            INTEGER (0..maxID),
    key                   SymmetricKey,
    newId                 INTEGER (1..maxID)
  }

  DecryptPayloadOperation ::= SEQUENCE {
    originalId            INTEGER (0..maxID),
    key                   SymmetricKey,
    newId                 INTEGER (1..maxID)
  }

END]]></artwork>
                    </figure>
                </t>
            </section>
            <section  anchor="asnOne_Ciphers" title="The VortexMessage Ciphers Structures">
                <t>
                    <figure>
                        <artwork src="asn/MessageVortex-Ciphers.asn"><![CDATA[MessageVortex-Ciphers DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  EXPORTS SymmetricKey, AsymmetricKey, MacAlgorithmSpec, CipherSpec;

  CipherSpec ::= SEQUENCE {
      asymmetric [16001] AsymmetricAlgorithmSpec OPTIONAL,
      symmetric  [16002] SymmetricAlgorithmSpec OPTIONAL,
      mac        [16003] MacAlgorithmSpec OPTIONAL,
      cipherUsage[16004] CipherUsage
  }

  CipherUsage ::= ENUMERATED {
    sign     (200),
    encrypt  (210)
  }

  SymmetricAlgorithmSpec  ::=  SEQUENCE  {
    algorithm               [16101]SymmetricAlgorithm,
    -- if ommited: pkcs1
    padding                 [16102]CipherPadding OPTIONAL,
    -- if ommited: cbc
    mode                    [16103]CipherMode OPTIONAL,
    parameter               [16104]AlgorithmParameters OPTIONAL
  }

  AsymmetricAlgorithmSpec  ::=  SEQUENCE  {
    algorithm               AsymmetricAlgorithm,
    parameter               AlgorithmParameters OPTIONAL
  }

  MacAlgorithmSpec  ::=  SEQUENCE  {
    algorithm               MacAlgorithm,
    parameter               AlgorithmParameters
  }

  PRNGAlgorithmSpec ::= SEQUENCE {
    type                    PRNGType,
    seed                    OCTET STRING
  }

  PRNGType ::= ENUMERATED {
    xsadd           (1000),
    blumMicali      (1001)
  }

  SymmetricAlgorithm ::= ENUMERATED {
    aes128          (1000),  -- required
    aes192          (1001),  -- optional support
    aes256          (1002),  -- required
    camellia128     (1100),  -- required
    camellia192     (1101),  -- optional support
    camellia256     (1102),  -- required
    twofish128      (1200),  -- optional support
    twofish192      (1201),  -- optional support
    twofish256      (1202)   -- optional support
  }

  CipherMode ::= ENUMERATED {
    -- ECB is a really bad choice. Do not use unless really
    -- necessary
    ecb             (10000),
    cbc             (10001),
    eax             (10002),
    ctr             (10003),
    ccm             (10004),
    gcm             (10005),
    ocb             (10006),
    ofb             (10007),
    none            (10100)
  }

  CipherPadding ::= ENUMERATED {
    none            (1000),
    pkcs1           (1001),
    pkcs7           (1002)
  }

  AsymmetricAlgorithm ::= ENUMERATED {
    rsa             (2000),
    dsa             (2100),
    ec              (2200),
    ntru            (2300)
  }

  MacAlgorithm ::= ENUMERATED {
    sha256          (3000),
    sha384          (3001),
    sha512          (3002),
    ripemd160       (3100),
    ripemd256       (3101),
    ripemd320       (3102)
  }

  ECCurveType ::= ENUMERATED{
    secp384r1       (2500),
    sect409k1       (2501),
    secp521r1       (2502)
  }

  AlgorithmParameters ::= SEQUENCE {
    keySize              [10000] INTEGER (0..65535) OPTIONAL,
    curveType            [10001] ECCurveType   OPTIONAL,
    initialisationVector [10002] OCTET STRING  OPTIONAL,
    nonce                [10003] OCTET STRING  OPTIONAL,
    mode                 [10004] CipherMode    OPTIONAL,
    padding              [10005] CipherPadding OPTIONAL,
    n                    [10010] INTEGER       OPTIONAL,
    p                    [10011] INTEGER       OPTIONAL,
    q                    [10012] INTEGER       OPTIONAL,
    k                    [10013] INTEGER       OPTIONAL,
    t                    [10014] INTEGER       OPTIONAL
  }

  -- Symmetric key
  SymmetricKey ::= SEQUENCE {
    keyType SymmetricAlgorithm,
    parameter AlgorithmParameters,
    key     OCTET STRING (SIZE(16..512))
  }

  -- Asymmetric Key
  AsymmetricKey ::= SEQUENCE {
    keyType       AsymmetricAlgorithm,
	-- private key encoded as PKCS#8/PrivateKeyInfo
    publicKey     [2] OCTET STRING,
	-- private key encoded as X.509/SubjectPublicKeyInfo
    privateKey    [3] OCTET STRING OPTIONAL
  }

END]]></artwork>
                    </figure>
                </t>
            </section>
            <section  anchor="asnOne_requests" title="The VortexMessage Request Structures">
                <t>
                    <figure>
                        <artwork src="asn/MessageVortex-Requests.asn"><![CDATA[MessageVortex-Requests DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  IMPORTS StatusBlock, ReplyNodes, ReplyCurrentQuota, ReplyCapability
                FROM MessageVortex-Replies
          RequirementBlock
                FROM MessageVortex-Requirements
          UsagePeriod, NodeSpec
                FROM MessageVortex-Helpers;

  HeaderRequest ::= CHOICE {
    identity      [0] HeaderRequestIdentity,
    capabilities  [1] HeaderRequestCapability,
    messageQuota  [2] HeaderRequestIncreaseMessageQuota,
    transferQuota [3] HeaderRequestIncreaseTransferQuota,
    quotaQuery    [4] HeaderRequestQuota,
    nodeQuery     [5] HeaderRequestNodes,
    replace       [6] HeaderRequestReplaceIdentity
  }

  SpecialBlock ::= CHOICE {
    capabilities  [1]  ReplyCapability,
    requirement   [2]  SEQUENCE (SIZE (1..127))
                       OF RequirementBlock,
    quota         [4]  ReplyCurrentQuota,
    nodes         [5]  ReplyNodes,
    status        [99] StatusBlock
  }

  HeaderRequestIdentity ::= SEQUENCE {
    period UsagePeriod
  }

  HeaderRequestReplaceIdentity ::= SEQUENCE {
	old			   NodeSpec,
	new            NodeSpec
  }

  HeaderRequestQuota ::= SEQUENCE {
  }

  HeaderRequestNodes ::= SEQUENCE {
    numberOfNodes   INTEGER
  }

  HeaderRequestIncreaseMessageQuota ::= SEQUENCE {
    messages INTEGER (0..4294967295)
  }

  HeaderRequestIncreaseTransferQuota ::= SEQUENCE {
    size     INTEGER (0..4294967295)
  }

  HeaderRequestCapability ::= SEQUENCE {
    period UsagePeriod
  }


END]]></artwork>
                    </figure>
                </t>
            </section>
            <section  anchor="asnOne_replies" title="The VortexMessage Replies Structures">
                <t>
                    <figure>
                        <artwork src="asn/MessageVortex-Replies.asn"><![CDATA[MessageVortex-Replies DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  EXPORTS StatusBlock, ReplyCurrentQuota, ReplyCapability,
          ReplyNodes;
  IMPORTS BlendingSpec, NodeSpec
                FROM MessageVortex-Helpers
          CipherSpec
                FROM MessageVortex-Ciphers;

  StatusBlock ::= SEQUENCE {
    code            StatusCode
  }

  StatusCode ::= ENUMERATED {

    -- System messages
    ok                          (2000),
    quotaStatus                 (2101),
    puzzleRequired              (2201),

    -- protocol usage failures
    transferQuotaExceeded       (3001),
    messageQuotaExceeded        (3002),
    requestedQuotaOutOfBand     (3003),
    identityUnknown             (3101),
    messageChunkMissing         (3201),
    messageLifeExpired          (3202),
    puzzleUnknown               (3301),

    -- capability errors
    macAlgorithmUnknown         (3801),
    symmetricAlgorithmUnknown   (3802),
    asymmetricAlgorithmUnknown  (3803),
    prngAlgorithmUnknown        (3804),
    missingParameters           (3820),
    badParameters               (3821),

    -- Mayor host specific errors
    hostError                   (5001)
  }

  ReplyNodes ::= SEQUENCE {
      node   SEQUENCE (SIZE (1..5))
             OF NodeSpec
  }

  ReplyCapability ::= SEQUENCE {
    cipher            SEQUENCE (SIZE (2..256)) OF CipherSpec,
    maxTransferQuota  INTEGER (0..4294967295),
    maxMessageQuota   INTEGER (0..4294967295),
    supportedBlendingIn SEQUENCE OF BlendingSpec
  }

  ReplyCurrentQuota ::= SEQUENCE {
    messages INTEGER (0..4294967295),
    size     INTEGER (0..4294967295)
  }

END]]></artwork>
                    </figure>
                </t>
            </section>
            <section  anchor="asnOne_requirements" title="The VortexMessage Requirements Structures">
                <t>
                    <figure>
                        <artwork src="asn/MessageVortex-Requirements.asn"><![CDATA[MessageVortex-Requirements DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  EXPORTS RequirementBlock;
  IMPORTS MacAlgorithmSpec
                FROM MessageVortex-Ciphers
          UsagePeriod, UsagePeriod
                FROM MessageVortex-Helpers;

  RequirementBlock ::= CHOICE {
    puzzle  [1] RequirementPuzzleRequired,
    payment [2] RequirementPaymentRequired
  }

  RequirementPuzzleRequired ::= SEQUENCE {
    -- bit sequence at beginning of hash from encrypted identity
    -- block
    challenge     BIT STRING,
    mac           MacAlgorithmSpec,
    valid         UsagePeriod,
    identifier    INTEGER (0..4294967295)
  }

  RequirementPaymentRequired ::= SEQUENCE {
    account       OCTET STRING,
    ammount       REAL,
    currency      Currency
  }

  Currency ::= ENUMERATED {
    btc      (8001),
    eth      (8002),
    zec      (8003)
  }

END]]></artwork>
                    </figure>
                </t>
            </section>
            <section  anchor="asnOne_helpers" title="The VortexMessage Helpers Structures">
                <t>
                    <figure>
                        <artwork src="asn/MessageVortex-Helpers.asn"><![CDATA[MessageVortex-Helpers DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  EXPORTS UsagePeriod, BlendingSpec, NodeSpec;
  IMPORTS AsymmetricKey, SymmetricKey
                FROM MessageVortex-Ciphers;

  -- the maximum number of parameters that might be embedded
  maxNumberOfParameter      INTEGER ::= 127

  UsagePeriod ::= SEQUENCE {
    notBefore       [0]     GeneralizedTime OPTIONAL,
    notAfter        [1]     GeneralizedTime OPTIONAL
  }

  -- contains a node spec of a routing point
  -- At the moment either smtp:<email> or xmpp:<jabber>
  BlendingSpec ::= SEQUENCE {
    target            [1] NodeSpec,
    blendingType      [2] IA5String,
    parameter         [3] SEQUENCE ( SIZE (0..maxNumberOfParameter) )
                          OF BlendingParameter
  }

  BlendingParameter ::= CHOICE {
    offset          [1] INTEGER,
    symmetricKey    [2] SymmetricKey,
    asymmetricKey   [3] AsymmetricKey,
    passphrase      [4] OCTET STRING
  }

  NodeSpec ::= SEQUENCE {
    transportProtocol [1] Protocol,
    recipientAddress  [2] IA5String,
    recipientKey      [3] AsymmetricKey OPTIONAL
  }

  Protocol ::= ENUMERATED {
    smtp  (100),
    xmmp  (110)
  }

END]]></artwork>
                    </figure>
                </t>
            </section>
            <section  anchor="asnOne_additional" title="The VortexMessage Additional Structures">
                <t>
                    <figure>
                        <artwork src="asn/MessageVortex-NonProtocolBlocks.asn"><![CDATA[-- States: Tuple()=Value() [vallidity; allowed operations] {Store}
-- - Tuple(identity)=Value(messageQuota,transferQuota,sequence of
--   Routingblocks for Error Message Routing) [validity; Requested
--   at creation; may be extended upon request] {identityStore}
-- - Tuple(Identity,Serial)=maxReplays ['valid' from Identity
--   Block; from First Identity Block; may only be reduced]
--   {IdentityReplayStore}

MessageVortex-NonProtocolBlocks DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  IMPORTS PrefixBlock, InnerMessageBlock, RoutingBlock, maxID
                FROM MessageVortex-Schema
          UsagePeriod, NodeSpec, BlendingSpec
                FROM MessageVortex-Helpers
          AsymmetricKey
                FROM MessageVortex-Ciphers
          RequirementBlock
                FROM MessageVortex-Requirements;

  -- maximum size of transfer quota in bytes of an identity
  maxTransferQuota          INTEGER ::= 4294967295
  -- maximum size of message quota in messages of an identity
  maxMessageQuota           INTEGER ::= 4294967295

  -- do not use these blocks for protocol encoding (internal only)
  VortexMessage ::= SEQUENCE {
    prefix        CHOICE {
        plain           [10011] PrefixBlock,
        -- contains prefix encrypted with receivers public key
        encrypted       [10012] OCTET STRING
    },
    innerMessage  CHOICE {
        plain     [10021] InnerMessageBlock,
        -- contains inner message encrypted with Symmetric key from
        -- Prefix
        encrypted [10022] OCTET STRING
    }
  }

  MemoryPayloadChunk ::= SEQUENCE {
    id                        INTEGER (0..maxID),
    payload                   [100] OCTET STRING,
    validity                  UsagePeriod
  }

  IdentityStore ::= SEQUENCE {
    identities SEQUENCE (SIZE (0..4294967295))
               OF IdentityStoreBlock
  }

  IdentityStoreBlock ::= SEQUENCE {
    valid               UsagePeriod,
    messageQuota        INTEGER (0..maxMessageQuota),
    transferQuota       INTEGER (0..maxTransferQuota),
    -- if omitted this is a node identity
    identity            [1001] AsymmetricKey OPTIONAL,
    -- if ommited own identity key
    nodeAddress         [1002] NodeSpec      OPTIONAL,
    -- Contains the identity of the owning node;
    -- May be ommited if local node
    nodeKey             [1003] SEQUENCE OF AsymmetricKey OPTIONAL,
    routingBlocks       [1004] SEQUENCE OF RoutingBlock OPTIONAL,
    replayStore         [1005] IdentityReplayStore,
    requirement         [1006] RequirementBlock OPTIONAL
  }

  IdentityReplayStore ::= SEQUENCE {
    replays   SEQUENCE (SIZE (0..4294967295))
              OF IdentityReplayBlock
  }

  IdentityReplayBlock ::= SEQUENCE {
    identity            AsymmetricKey,
    valid               UsagePeriod,
    replaysRemaining  INTEGER (0..4294967295)
  }

END]]></artwork>
                    </figure>
                </t>
            </section>
        </section>
        <!-- Change Log

            v010 2018-08-19  GwM   Initial version
            v011 2018-09-12  GwM   Added some Feedback from Marc

        -->
    </back>
</rfc>
