<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd"[ ]>

<?rfc strict="yes" ?>
<?rfc toc="yes"?>
<?rfc tocdepth="4"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes" ?>
<?rfc compact="yes" ?>
<?rfc subcompact="no" ?>

<rfc category="exp" docName="draft-ietf-messagevortex_protocol-00" ipr="trust200902" xml:lang='en'>
    <front>

        <title>MessageVortex Protocol</title>

        <author fullname="Martin Gwerder" surname="Gwerder">
            <address>
                <postal>
                    <street>Untere Parkstrasse 9</street>
                    <code>5212</code><city>Hausen</city><region>AG</region>
                    <country>Switzerland</country>
                </postal>
                <phone>+41 56 202 76 81</phone>
                <email>rfc@messagevortex.net</email>

            </address>
        </author>

        <date year="2018"/>

        <area>General</area>

        <workgroup>Internet Engineering Task Force</workgroup>

        <keyword>SMTP</keyword>
        <keyword>XMPP</keyword>
        <keyword>IMAPrev4</keyword>
        <keyword>MessageVortex</keyword>
        <keyword>Anonymity</keyword>

        <abstract>
            <t>
                MessageVortex Protocol specifies messages embedded within existing transfer protocols such  as SMTP (<xref target="RFC5321"/>) or XMPP (<xref target="RFC6120"/>) to send them anonymously from peer to peer.
            </t>
            <t>
                The protocol outperforms other protocols by decoupling transport from the final transmitter and receiver party. There is no trust put into any infrastructure except for the infrastructure of the sending and receiving party of a message. The Message flow is entirely selected by the creator of the routing block. Routing nodes gain no unobvious knowledge about messages even when collaborating. Third-party anonymity is always achieved. Furthermore, one out of sender, and receiver anonymity may be achieved.
            </t>
        </abstract>
    </front>

    <middle>
        <section title="Introduction">
            <t>Anonymization is hard to achieve. Most of the attempts in the past rely on either a trust upon a dedicated infrastructure or a specialized networking protocol.</t>
            <t>
                MessageVortex is a protocol which allows to send and receive messages by using a routing block instead of a destination address.
                The sender has full control over all parameters of the message flow.
            </t>
            <t>
                A message may be split and reassembled during transmission. Chunks of the message may carry redundant information to avoid service interruptions of the message transit. Decoy traffic and message traffic are not differentiable as the nature of the addRedundancy operation allows each generated part to be a message part or decoy. Any routing node is thus unable to differentiate between the message and decoy traffic.
            </t>
            <t>
                Any Receiver knows after processing whether a message is destined for it or other nodes.
            </t>
            <t>
                This RFC is structured in such a way that first the terminology is introduced (see <xref target="entities_overview"/>). Next, a general overview of the process is given (see <xref target="layer_overview"/>). Lastly, the protocol is described in details in the subsequent sections.
            </t>

            <section title="Requirements Language">
                <t>The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.</t>
            </section>

            <section title="Protocol Specification">
                <t>The protocol is specified as in <xref target="asn_one"/> in ASN.1 (see <xref target="CCITT.X680.2002"/> and <xref target="CCITT.X208.1988"/>). The blocks are if not otherwise mentioned DER encoded.</t>
            </section>
        </section>

        <section anchor="entities_overview" title="Entities Overview">
            <t>Within this document, we refer to the entities as defined below. </t>
            <section anchor="entities_node" title="Node">
                <t>
                    We use the term 'node' to  describe any system connected to other nodes, and supporting the MessageVortex Protocol. As the protocol is typically linked to a transport layer address, a 'node' is typically an email address, an XMPP address, or any other transport protocol identity supporting the MessageVortex protocol.
                </t>
            </section>
            <section anchor="entities_peer" title="Peer Partner">
                <t>
                    We use the term 'peer partner' as two or more message sending or receiving entities. One of these peer partners is the sends a message and all other peer partner receive one or more messages. Peer partners are message specific. Every peer partner is connected to a node.
                </t>
            </section>
            <section anchor="entities_keys" title="Encryption keys">
               <t>
                   There are several keys required for a Vortex message. Some of them are used as an identity, and some are message specific.
               </t>
               <section anchor="entities_node_identity" title="Identity Keys">
                   <t>
                       Every participant of the network has an asymmetric key. These keys SHOULD be either EC keys with a minimum length of 384 bits or RSA keys with a minimum length of 2048 bits.
                   </t>
                   <t>
                       The public key needs to be known by all parties writing to or through that node.
                   </t>
               </section>
               <section anchor="entities_keys_peer" title="Peer Key">
                   <t>
                       Peer keys are symmetrical keys transmitted with a Vortex message. Peer keys are always known to the node sending a message, the node receiving the message from the sender, and to the creator of the routing block.
                   </t>
                   <t>
                       A peer key is included in the identity block of a Vortex message and in the building instructions for a Vortex message (see RoutingCombo in <xref target="asn_one"/>).
                   </t>
               </section>
               <section anchor="entities_keys_sender" title="Sender Key">
                   <t>
                       The sender key is a symmetrical key protecting the identity and routing block of a Vortex message. It is encrypted with the receiving peer key and prefixed to the identity block. This key decouples further identity and processing information from the previous key.
                   </t>
                   <t>
                       A sender key is known to precisely one peer of a Vortex message and the creator of the routing block.
                   </t>
               </section>
            </section>
            <section anchor="entities_vortex_message" title="Vortex Message">
                <t>
                    We use the term 'Vortex message' for a single transmission between two routing layers. A 'blended Vortex message' describes a Vortex message which has been adapted to the transport layer by the blending layer (see <xref target="layer_overview"/>).
                </t>
                <t>
                    A Vortex message may be sent anonymously. There are however different degrees of anonymity.

                    <list style="symbols">
                        <t>If the sender of a message is not known to anyone else except the sender, we refer to that as 'sender anonymity.'</t>
                        <t>If the receiver of a message is not known to anyone else except the receiver, we refer to that as 'receiver anonymity.'</t>
                        <t>If neither sender nor receiver can be determined by any other party, we refer to that as third-party anonymity.</t>
                        <t>If a sender or a receiver may be determined as "one of a set of &lt;k&gt; entities we refer to it as k-anonymity (for more about this see <xref target="KAnon"/>).</t>
                    </list>
                </t>
                <t>
                    A full vortex message is built of the following items:
                    <list style="symbols">
                        <t>The peer key (encrypted with the host key of the node) protecting the inner Vortex message.</t>
                        <t>The short padding guarantees that a replayed routing block with different content does not look alike.</t>
                        <t>The sender key (encrypted with the host key of the node) protecting the identity and routing block.</t>
                        <t>The identity block (protected by the sender key) containing information about the ephemeral identity of the sender, replay protection information, header requests (optional) and a requirement reply (optional).</t>
                        <t>The routing block (protected by the sender key) containing information on how subsequent messages are processed, assembled and blended.</t>
                        <t>The payload block (protected by the peer key) containing payload chunks to be processed.</t>
                    </list>
                </t>
            </section>
            <section anchor="entities_blocks" title="Blocks">
                <t>We use the term 'block' for an ASN.1 sequence in a packet.  A packet may have any size and is embedded in the transport protocol. It must not be confused with network packets.</t>
            </section>
            <section anchor="entities_transport_address" title="Transport Address">
                <t>We use the term 'transport address' for the token required to address the next immediate node on the transport layer.  An email transport layer would have SMTP addresses such as 'vortex@example.com' as transport address.</t>
            </section>
            <section anchor="entities_identity" title="Identity">
                <section anchor="entities_identity_peer" title="Peer Identity">
                    <t>The peer identity may contain the following information of a peer partner:
                        <list style="symbols">
                            <t>The transport address (always) and the public key of this identity (if no recipient anonymity is given)</t>
                            <t>The routing blocks for contacting the identity (optional; usually in the case of recipient anonymity)</t>
                            <t>The private key (only known by the owner of the identity)</t>
                        </list>
                    </t>
                </section>
                <section anchor="entities_identity_ephemeral" title="Ephemeral Identity">
                    <t>Ephemeral identities are temporary identities created on a single node. These identities MUST NOT be connected to any other identity. They allow bookkeeping for a node. To each ephemeral identity is a workspace assigned. Every ephemeral identity may have multiple quotas assigned.
                    </t>
                </section>
                <section anchor="entities_identity_official" title="Official Identity">
                    <t>An official identity may have the following items assigned:
                        <list style="symbols">
                            <t>Routing blocks to be used to reply to the node.</t>
                            <t>A list of assigned ephemeral identities on all other nodes and their projected quotas.</t>
                            <t>A list of known nodes and the respective node identity</t>
                        </list>
                    </t>
                </section>
            </section>
            <section anchor="entities_workspace" title="Workspace">
                <t>Every official or ephemeral identity has a workspace. A workspace consists of the following elements:
                    <list style="symbols">
                        <t>Zero or more routing blocks to be processed</t>
                        <t>Slots for payload block sequentially numbered</t>
                    </list>
                </t>
            </section>
        </section>

        <section anchor="layer_overview" title="Layer Overview">
            <t>The protocol is designed in four layers as shown in <xref target="fig_layer_overview" /></t>

            <figure align="center" anchor="fig_layer_overview" title="Layer overview">
                <artwork align="center"><![CDATA[
+-------------------------------------------------------------------+
| Vortex Node                                                       |
| +---------------------------------------------------------------+ |
| |                        Accounting                             | |
| |_______________________________________________________________| |
|                                                                   |
| +---------------------------------------------------------------+ |
| |                          Routing                              | |
| |_______________________________________________________________| |
|                                                                   |
| +----------------------------+ +--------------------------------+ |
| |           Blending         | |             Blending           | |
| |____________________________| |________________________________| |
|___________________________________________________________________|
  +----------------------------+ +--------------+ +---------------+
  |          Transport         | | Transport in | | Transport out |
  |____________________________| |______________| |_______________|
               ]]></artwork>
            </figure>

            <t>
                Every participating node MUST implement the layers blending, routing, and accounting.  There MUST be at least one incoming and one outgoing transport layer available to a node. All blending layers SHOULD be connected to respective Transport layers for sending and receiving packets.
            </t>

            <section anchor="layer_overview_transport" title="Transport Layer">
                <t>The transport layer embeds the blended MessageVortex packets into the data stream of the existing transport layer protocol.</t>
                <t>The transport layer infrastructure SHOULD NOT be specific to anonymous communication and should contain significant parts of non-MessageVortex traffic.</t>
            </section>

            <section anchor="layer_overview_blending" title="Blending Layer">
                <t>The blending layer embeds MessageVortex packets into the transport layer data stream and extracts MessageVortex packets from the transport layer.</t>
            </section>
            <section anchor="layer_overview_routing" title="Routing Layer">
                <t>The Routing Layer expands information contained in MessageVortex packets, processes them, and passes generated  packets to the respective Blending Layer.</t>
            </section>
            <section anchor="layer_overview_accounting" title="Accounting Layer">
                <t>The accounting layer keeps track of all ephemeral identities authorized to use a MessageVortex node. Especially it verifies the available quotas to an ephemeral identity.
                </t>
            </section>
        </section>

        <section title="Vortex Message">
            <section title="Overview">
                <t>
                    <xref target="fig_message_overview"/> shows a Vortex message. The enclosed sections denote encrypted blocks. The three to four letter abbreviations denote the key required for decryption. The abbreviation k_h stands for the asymmetric host key. s_kp is the symmetric peer key. This key is obtained by the receiving node by decrypting MPREFIX with its host key k_h. sk_s is the symmetric sender key. This key is obtained by decrypting the MPREFIX block. The header and routing blocks are protected by the sender key. This key makes sure that the node assembling the message dos not have knowledge about upcoming identities, operations, and requests. The peer key protects the message including structure from any third party observer.
                    <figure align="center" anchor="fig_message_overview" title="Vortex message overview">
                        <artwork align="center"><![CDATA[
+-+---+-+-+---+-+---+-+-+---+-+-+---+-+-------+-+
| |   | | |   | | C | | |   | | | R | |       | |
| |   | | |   | | P | | | H | | | O | |       | |
| | M | | | P | | R | | | E | | | U | |   P   | |
| | P | | | A | | E | | | A | | | T | |   A   | |
| | R | | | D | | F | | | D | | | I | |   Y   | |
| | E | | | D | | I | | | E | | | N | |   L   | |
| | F | | | I | | X | | | R | | | G | |   O   | |
| | I | | | N | +---+ | |___| | |___| |   A   | |
| | X | | | G |  k_h  | sk_s  | sk_s  |   D   | |
| |___| | |___|_______|_______|_______|_______| |
|  k_h  |                  sk_p                 |
|_______|_______________________________________|
                        ]]></artwork>
                    </figure>
                </t>
            </section>
            <section title="Message Prefix Block (MPREFIX)">
                <t>
                    The PrefixBlock contains a symmetrical key as defined in <xref target="app_asnOne"/> and is encrypted using the host key of the receiving peer host. The symmetric key used MUST be one out of the set advertised by a CapabilitiesReplyBlock (see <xref target="routing_header_req_cap"/>). Parameters omitted in the CapabilitiesReplyBlock MAY be freely chosen. A PrefixBlock SHOULD always be encrypted with the hosts public key. A prefix block MUST contain the same forward-secret as the other prefix, the routing block, and the header block. A host MAY reply to a message with an unencrypted message block. Any reply to a message SHOULD be encrypted.
                </t>
                <t>
                    The sender MUST choose a key which may be encrypted with the host key using the padding advertised by the CapabilitiesReplyBlock.
                </t>
            </section>
            <section title="Inner Message Block">
                <t>
                    The InnerMessageBlock MUST be encrypted with the symmetric key of the PrefixBlock. The encryption hides the inner structure of the message. The InnerMessageBlock SHOULD always accommodate four or more payload chunks.
                </t>
                <t>
                    An InnerMessageBlock always starts with a padding block. This padding guarantees that when using the same routing block multiple times. The padding MUST be the first 16 bytes of the first four PayloadChunks. If a PayloadChunk is shorter than 16 bytes, the content of the padding SHOULD be filled with zero-valued bytes (00h) at very end up to the required number of bytes. An InnerMessageBlock SHOULD contain at least four PayloadChunks sized 16 bytes or bigger. If there are less than four payload chunks, then the padding MUST contain a random sequence of 16 bytes for the missing payload chunks. Random sequences SHOULD NOT be reused.
                </t>
                <section title="Control Prefix Block">
                    <t>The control prefix block (CPREFIX) is built exactly as the MPREFIX block. It contains the sender key  sk_s. This block may be omitted if the MPREFIX block was unencrypted. The control blocks (HeaderBlock and RoutingBlock) are unencrypted if CPREFIX is omitted.</t>
					<t>
						A prefix block MUST contain the same forward-secret as the other prefix, the routing block, and the header block. 
					</t>	
                </section>
                <section title="Control Blocks">
                    <t>
                        The control blocks contain the core information to process the payload. It contains a HeaderBlock and a RoutingBlock.
                    </t>
                    <section title="Header Block">
                        <t>
                            The header block (see HeaderBlock in <xref target="asn_one"/>) contains the following information:
                            <list style="symbols">
                                <t>It MUST contain the local ephemeral identity of the routing block builder.</t>
                                <t>It MAY contain header requests.</t>
                                <t>It MAY solve a requirement previously opposed to a header request.</t>
                            </list>
                        </t>
                        <t>
                            The list of header requests MAY be empty, contain a single identity create request (HeaderRequestIdentity), or MUST not contain more than one increase quota request. If header block violates these rules, then a node MUST NOT reply to any header requests. Payload and routing blocks SHOULD still be added to the workspace and processed, given the message quota is not exceeded.
                        </t>    
                    </section>
                    <section title="Routing Block">
                        <t>
                            The routing block (see RoutingBlock in <xref target="asn_one"/>) contains the following information:
                            <list style="symbols">
								<t>It MUST contain a serial number uniquely identifying the routing block of this user</t>
								<t>It MUST contain the same forward secret as the two prefix and the header block.</t>
                                <t>It MAY contain assembly and processing instructions for subsequent messages</t>
								<t>It MAY contain a reply block for messages assigned to the owner of the identity.</t>
                            </list>
                        </t>
                    </section>
                </section>
                <section title="Payload Block">
                    <t>Each InnerMessageBlock SHOULD contain at least four PayloadChunks.</t>
                </section>
            </section>
        </section>

        <section title="General notes">
            <t>
                The  MessageVortex protocol is modularly built. It allows using different encryption algorithms. For operation, a Vortex node SHOULD always support at least two completely different types of algorithms, paddings, or modes.
            </t>
            <section title="Supported Symmetric Ciphers">
                <t>
                    A node MUST support the following symmetric ciphers:
                    <list style="symbols">
                        <t>AES128</t>
                        <t>AES256</t>
                        <t>CAMELLIA128</t>
                        <t>CAMELLIA256</t>
                    </list>
                    Any standardized key size bigger than the smallest key above SHOULD be supported.
                </t>
                <t>The Twofish cipher MAY be supported.</t>
            </section>
            <section title="Supported Asymmetric Ciphers">
                <t>
                    A node MUST support the following asymmetric ciphers:
                    <list style="symbols">
                        <t>RSA (key sizes bigger or equal to 2048)</t>
                        <t>ECC (named curves secp384r1, sect409k1, secp521r1)</t>
                    </list>
                </t>
            </section>
            <section title="Supported MACs">
                <t>
                    A node MUST support the following Message Authentication Codes (MAC):
                    <list style="symbols">
                        <t>SHA256</t>
                        <t>RipeMD160</t>
                    </list>
                </t>
                <t>
                    A node SHOULD support the following MACs:
                    <list style="symbols">
                        <t>SHA512</t>
                        <t>RipeMD256</t>
                        <t>RipeMD512</t>
                    </list>
                </t>
            </section>
            <section title="Supported Paddings">
                <t>
                    A node MUST support the following paddings:
                    <list style="symbols">
                        <t>PKCS1</t>
                        <t>PKCS7</t>
                    </list>
                </t>
            </section>
            <section title="Supported Modes">
                <t>
                    A node MUST support the following modes:
                    <list style="symbols">
                        <t>CBC</t>
                        <t>EAX</t>
                        <t>GCM</t>
                    </list>
                    ECB and NONE SHOULD NOT be used.
                </t>
                <t>
                    A node SHOULD support the following modes:
                    <list style="symbols">
                        <t>CTR</t>
                        <t>CCM</t>
                        <t>OCB</t>
                        <t>OFB</t>
                    </list>
                </t>
            </section>
        </section>

        <section anchor="blending" title="Blending">
            <t>Each node supports a fixed set of blending capabilities. They may be different for incoming and outgoing messages.
            </t>
            <t>
                The following sections describe the blending mechanism. There are currently two blending layers specified. One layer specification for the simple mail transfer protocol (SMTP; See <xref target="RFC5321"/>) and one for the Extensible Messaging and Presence Protocol (XMPP; See <xref target="RFC6120"/>).
            </t>
            <section anchor="blending_general" title="Blending in Attachments">
                <t>
                    There are two types of blending supported when using attachments.
                    <list style="symbols">
                        <t>Plain binary encoding with offset (PLAIN)</t>
                        <t>Embedding with F5 in an image (F5)</t>
                    </list>
                </t>
                 <t>
                    For interoperability, PLAIN blending MUST be supported. Blending using F5 MAY be supported.
                </t>
                <section anchor="blending_general_plain" title="PLAIN embedding into attachments">
                    <t>
                        Within this document refer to PLAIN blending if a Vortex message is embedded in a carrier file with an offset. An offset of 0 means that the beginning of the payload file is replaced. The routing node MUST choose what payload file is used for the message. A routing node SHOULD use a credible payload type with high entropy. It furthermore SHOULD prefix a valid header structure to avoid easy detection of the Vortex message. A routing node MAY attach a valid footer to a payload file to improve blending.
                    </t>
                    <t>
                        A node SHOULD offer at least one PLAIN blending method for incoming Vortex messages. A node may offer multiple offsets for incoming Vortex messages.
                    </t>
                </section>
                <section anchor="blending_general_F5" title="F5 embedding into attachments">
                    <t>
                        Within this document, we refer to F5 blending if a Vortex message is blended into a JPEG image according to algorithms specified in <xref target="F5"/>. The password for blending may be publicly known. A routing node may advertise multiple passwords. It should be understood that this blending mechanism adds a tenfold of transfer volume to the message. Only small message chunks SHOULD be blended with F5.
                    </t>
                </section>
            </section>
            <section anchor="blending_smtp" title="Blending into an SMTP layer">
                <t>
                    Email messages containing messages MUST be encoded with Multipurpose Internet Mail Extensions (MIME) as specified in <xref target="RFC2045"/>. Encoding mechanism BASE64 MUST be supported. All sections of an email are tested for the presence of a Vortex message.
                </t>
                <t>
                    A vortex message is present if a block containing the peer key at the known offset of any MIME part decodes correctly.
                </t>
                <t>
                    To work correctly, when blending protocols for sending and receiving SHOULD be supported. For sending SMTP as specified in <xref target="RFC5321"/> must be used. TLS protection as specified in <xref  target="RFC3207"/> SHOULD be applied. For obtaining any messages protocols such as POP3 (as specified in <xref target="RFC1939"/> and <xref target="RFC2595"/>) or IMAP (as specified in <xref target="RFC3501"/>) SHOULD always be secured by TLS layers.
                </t>
            </section>
            <section anchor="blending_xmpp" title="Blending into an XMPP layer">
                <t>For interoperability, this layer SHOULD be implemented.</t>
                <t>
                  Blending into XMPP traffic is done using the <xref target="XEP-0234"/> extension of the XMPP protocol.
                </t>
                <t>
                    All rules for embedding within the protocol may be taken from the general section. PLAIN and F5 blending is acceptable for this transport layer.
                </t>
            </section>
        </section>

        <section anchor="routing" title="Routing">
            <section anchor="routing_message" title="Vortex Message Processing">
                <section anchor="routing_incoming" title="Processing of incoming Vortex Messages">
                    <t>
                        An incoming message is first unauthenticated. A message is authenticated as soon as the ephemeral identity is known and is not temporary.
                    </t>
                    <t>
                        For an unauthenticated message the following rules apply:
                        <list style="symbols">
                            <t>A node MUST ignore all Routing blocks.</t>
                            <t>A node MUST ignore all Payload blocks.</t>
                            <t>A node SHOULD accept identity creation requests in unauthenticated messages.</t>
                            <t>A node MUST ignore any other header request except identity creation requests.</t>
                            <t>A node MUST ignore all identity creation requests which belong to an already existing identity.</t>
                        </list>
                    </t>
                    <t>
                        A message is authenticated as soon as the identity used in the header block is known and not temporary. For authenticated messages the following rules apply:
                        <list style="symbols">
                            <t>A node MUST ignore identity creation requests.</t>
                            <t>A node SHOULD process all header requests.</t>
                            <t>A node SHOULD add all routing blocks to the workspace.</t>
                            <t>A node SHOULD add all payload blocks to the workspace.</t>
                        </list>
                        A routing node MUST decrement the message quota by one if a received message is authenticated and contains at least one payload block.
                    </t>
                </section>
                <section anchor="routing_workspace" title="Processing of Routing Blocks in Workspace">
                    <t>FIXME</t>
                </section>
                <section anchor="routing_outgoing" title="Processing of Outgoing Routing Blocks">
                    <t>FIXME</t>
                </section>
            </section>
            <section anchor="routing_header" title="Header Requests">
                <section anchor="routing_header_eid" title="Request New Ephemeral Identity">
                    <t>FIXME</t>
                </section>
                <section anchor="routing_header_req_msg_quota" title="Request Message Quota">
                    <t>FIXME</t>
                </section>
                <section anchor="routing_header_req_trans_quota" title="Request Transfer Quota">
                    <t>FIXME</t>
                </section>
                <section anchor="routing_header_qry_quota" title="Query Quota">
                    <t>FIXME</t>
                </section>
                <section anchor="routing_header_req_cap" title="Request Capabilities">
                    <t>FIXME</t>
                </section>
                <section anchor="routing_header_req_nodes" title="Request Nodes">
                    <t>FIXME</t>
                </section>
                <section anchor="routing_header_req_identity_replace" title="Request Identity Replace">
                    <t>FIXME</t>
                </section>
            </section>
            <section anchor="routing_operations" title="Routing Operations">
                <t>FIXME</t>
            </section>
            <section anchor="routing_processing" title="Processing of Vortex Messages">
                <t>FIXME</t>
            </section>
        </section>

        <section anchor="accounting" title="Accounting">
            <section anchor="accounting_create_identity" title="Ephemeral Identity Creation">
                <t>The accounting layer has two major kinds of operations:
                    <list style="symbols">
                        <t>Time-based operations (cleanup jobs and initiation of routing)</t>
                        <t>Routing triggered operations (updating quotas, authorizing operations, and pickup of incoming messages.)</t>
                    </list>

                    Implementations MUST provide sufficient locking mechanisms to guarantee the integrity of accounting information and workspace at any time.
                </t>
                <section anchor="accounting_timed_gc" title="Time-Based Garbage Collection">
                    <t>FIXME</t>
                </section>
                <section anchor="accounting_timed_routing" title="Time-Based Routing Initiation">
                    <t>FIXME</t>
                </section>
                <section anchor="accounting_timed_quota" title="Routing Based Quota Updates">
                    <t>FIXME</t>
                </section>
                <section anchor="accounting_routhing_auth" title="Routing Based Authorization">
                    <t>FIXME</t>
                </section>
            </section>
        </section>

        <section anchor="Acknowledgments" title="Acknowledgments">
            <t>FIXME</t>
        </section>

        <section anchor="IANA" title="IANA Considerations">
            <t>This memo includes no request to IANA.</t>

            <t>Additional encryption algorithms, paddings, modes, blending layers, or puzzles MUST be added by writing an extension to this or a subsequent RFC. For testing purposes, IDs above 1,000,000 should be used.</t>
        </section>

        <section anchor="Security" title="Security Considerations">
            <t>The MessageVortex protocol may be understood more as a toolset than a fixed product. Depending on the usage of the toolset anonymity and security are affected. For a detailed analysis see <xref target="MessageVortexAnalysis"/>.
            </t>
            <t>
                The primary goals for security within this protocol did rely on the following focus areas:
                <list style="symbols">
                    <t>Confidentiality</t>
                    <t>Integrity</t>
                    <t>Availability</t>
                    <t>Anonymity
                        <list style="symbols">
                            <t>3rd party anonymity</t>
                            <t>sender anonymity</t>
                            <t>receiver anonymity</t>
                        </list>
                    </t>
                </list>

                All these factors are affected by the usage of the protocol. The following sections provide a list of factors affecting the primary goals.
            </t>
            <t>
                The Vortex protocol does not rely on any encryption on the transport layer. Vortex messages are already encrypted. Confidentiality is not affected by protection mechanisms of the transport layer.
            </t>
            <t>
                If a transport Layer supports encryption, a Vortex node SHOULD use it to improve the privacy of the message.
            </t>
            <t>
                Anonymity is affected by the inner workings of the blending layer in many ways. A Vortex message cannot be read by anyone except the peer nodes and the routing block builder, but the presence of a vortex node message may be detected. This may be done either by detecting the typical high entropy of an encrypted file, broken structures of a carrier file, a meaningless content of a carrier file, or the contextless communication of the blending layer with its peer partner. A blending layer SHOULD minimize the possibility of easy detection by minimizing these effects.
             </t>
             <t>
                A blending layer SHOULD use carrier files with high compression or encryption. Carrier files SHOULD NOT have inner structures so that the payload is comparable to valid content. To achieve undetectability by a human reviewer, a routing block builder should use F5 blending instead of PLAIN blending.
             </t>
             <t>
                The two layers routing and accounting have the deepest insight into a Vortex message's inner working. They know the immediate peer sender and the peer recipients of all payload chunks. As decoy traffic is generated by combining chunks and applying redundancy calculations upon them, a node may never know whether a malfunction (e.g., when doing a recovery calculation) was intended or not. Therefore a node may not know what traffic was intended to fail or not. It furthermore cannot tell content from decoy traffic apart.
             </t>
             <t>
                A routing block builder SHOULD follow the following rules in order not to compromise a Vortex message's anonymity:
                <list style="symbols">
                    <t>All operations applied SHOULD be credible to be involved in a message transfer.</t>
                    <t>There should always be a sufficient subset of the result of an addRedundancy operation sent to peers to allow recovery of the data built.</t>
                    <t>The anonymity set of a message should be sufficiently large to avoid legal prosecution of all jurisdictional entities involved. It has even to be large enough if a certain amount of the anonymity set cooperates with an adverser.</t>
                    <t>Encryption and decryption SHOULD follow whenever possible the logic. Avoid encrypting a block on a node with one key and decrypting it with a different key on the same or another node.</t>
                    <t>Traffic peaks SHOULD be uniformly distributed within the whole anonymity set.</t>
                    <t>A routing block SHOULD be used for a limited  number of messages. If used as a message block for the node itself it should be used only once. A block builder SHOULD use the identity replace header request to update reply blocks on a regular base. Implementers should always keep in mind that the same routing block is identifiable as such by its structure.</t>
                    <t>A block builder SHOULD always rely on the newest possible research when choosing Cipher types, paddings, and modes to stay secure.</t>
                </list>
             </t>
             <t>
                An active adverser cannot use foreign blocks for his purposes. He may falsify the result by injecting wrong message chunks or by not sending a message. Such message disruptions may be detected by intentionally routing some information to the routing block builders node. If the Vortex message does not carry the information expected the node may safely assume that one of the involved nodes is misbehaving. A block building node MAY calculate reputation for involved nodes over time. A block building node MAY build redundancy paths into a routing block to withstand such malicious nodes.
            </t>
            <t>
                A peer node may try to exhaust a routers quota by sending multiple times the same block. A block builder should take care that a block may not be resent in the interval where the previous blocks for the transaction are still valid. This guarantees that replayed blocks will stop at the next peer node. This provides good protection against replay based attacks.
            </t>
        </section>
    </middle>

    <!--  *****BACK MATTER ***** -->

    <back>
        <references title="Normative References">
            <!-- Use of words -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2119.xml"?>

            <reference anchor="CCITT.X208.1988">
                <front>
                    <title>Specification of Abstract Syntax Notation One (ASN.1)</title>
                    <author>
                        <organization>International Telephone and Telegraph Consultative Committee</organization>
                    </author>
                    <date year="1998" month="11"/>
                </front>
                <seriesInfo name="CCITT Recommendation" value="X.208"/>
            </reference>

            <reference anchor="CCITT.X680.2002">
                <front>
                    <title>Abstract Syntax Notation One (ASN.1): Specification of basic notation</title>
                    <author>
                        <organization>International Telephone and Telegraph Consultative Committee</organization>
                    </author>
                    <date year="2002" month="11"/>
                </front>
                <seriesInfo name="CCITT Recommendation" value="X.680"/>
            </reference>

            <reference anchor="XEP-0234">
                <front>
                    <title>XEP-0234: Jingle File Transfer</title>
                    <author surname="Peter" initials="S.A"/>
                    <author surname="Stout" initials="L"/>
                    <date year="2017" month="08" day="24"/>
                </front>
            </reference>

            <reference anchor="F5">
                <front>
                    <title>F5 - A Steganographic Algorithm - High Capacity Despite Better Steganalysis</title>
                    <author initials="A" surname="Westfeld">
                        <organization>TU Dresden</organization>
                    </author>
                    <date year="2001" month="10" day="24"/>
                </front>
            </reference>

        </references>

        <references title="Informative References">

            <!-- MIME -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2045.xml"?>
            <!-- XMPP -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.6120.xml"?>
            <!-- SMTP -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.5321.xml"?>
            <!-- SMTP STARTTLS-->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3207.xml"?>
            <!-- IMAP -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.3501.xml"?>
            <!-- POP3 -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.1939.xml"?>
            <!-- POP3 STARTTLS -->
            <?rfc include="http://xml.resource.org/public/rfc/bibxml/reference.RFC.2595.xml"?>

            <reference anchor="MessageVortexAnalysis" target="https://www.gwerder.net/phd/phd/doc/messageVortex.pdf">
                <front>
                    <title>MessageVortex</title>
                    <author initials="M" surname="Gwerder"/>
                    <date year="2018" />
                </front>
            </reference>

            <reference anchor="KAnon">
                <front>
                    <title>k-Anonymous Message Transmission</title>
                    <author initials="L" surname="Ahn">
                        <organization>Carnegie Mellon University</organization>
                    </author>
                    <author initials="A" surname="Bortz">
                        <organization>Carnegie Mellon University</organization>
                    </author>
                    <author initials="NJ" surname="Hopper">
                        <organization>Carnegie Mellon University</organization>
                    </author>
                    <date year="2003" />
                </front>
            </reference>

        </references>

        <section anchor="asn_one" title="The ASN.1 schema for Vortex messages">
            <figure align="left" anchor="app_asnOne">
                <artwork><![CDATA[
-- encryption: as specified in the key. If not specified default 
-- mode is CBC and default padding is PKCS1Padding

-- States: Tuple()=Value() [vallidity; allowed operations] {Store}
-- - Tuple(identity)=Value(messageQuota,transferQuota,sequence of
--   Routingblocks for Error Message Routing) [validity; Requested
--   at creation; may be extended upon request] {identityStore}
-- - Tuple(Identity,Serial)=maxReplays ['valid' from Identity 
--   Block; from First Identity Block; may only be reduced]
--   {IdentityReplayStore}

MessageBlocks DEFINITIONS EXPLICIT TAGS ::=
BEGIN
  -----------------------------------------------------------------
  -- Constant definitions
  -----------------------------------------------------------------
  -- maximum serial number
  maxSerial                 INTEGER ::= 4294967295
  -- maximum size of a message chunk
  maxChunkSize              INTEGER ::= 4294967295
  -- minimum size of a message chunk (should be -maxChunkSize)
  minChunkSize              INTEGER ::= -maxChunkSize
  -- maximum size of transfer quota in bytes of an identity
  maxTransferQuota          INTEGER ::= 4294967295
  -- maximum size of message quota in messages of an identity
  maxMessageQuota           INTEGER ::= 4294967295
  -- maximum number a block may be replayed
  maxNumberOfReplays        INTEGER ::= 127
  -- maximum number of administrative requests
  maxNumberOfRequests       INTEGER ::= 8
  -- maximum number of seconds which the message might be delayed 
  -- in the local queue (starting from startOffset)
  maxDurationOfProcessing   INTEGER ::= 86400
  -- maximum id of an operation
  maxID                     INTEGER ::= 32767
  -- maximum number of routing blocks in a message
  maxRoutingBlocks          INTEGER ::= 127
  -- maximum number of payload chunks in a message
  maxPayloadBlocks          INTEGER ::= 127
  -- maximum number of seconds a proof of non revocation may be old
  maxTimeCachedProof        INTEGER ::= 86400
  -- maximum omega of the Galois field used
  maxGFSize                 INTEGER ::= 16
  -- the maximum number of parameters that might be embedded
  maxNumberOfParameter      INTEGER ::= 127
  -- The maximum ID of the workspace 
  maxWorkspaceId            INTEGER ::= 65535
  -- The maximum number of assembly instructions per combo
  maxAssemblyInstructions   INTEGER ::= 255

  -----------------------------------------------------------------
  -- Block Definitions
  -----------------------------------------------------------------
  RoutingBlock ::= SEQUENCE {
    -- contains the period when the payload should be processed
    -- Router might refuse to long queue retention
    -- Recommended support for retention >=1h
    minProcessTime INTEGER (0..maxDurationOfProcessing),
    maxProcessTime INTEGER (0..maxDurationOfProcessing),
    -- contains the prefix to be used
    routing    CHOICE {
      -- debug/internal use only
      plain             [331] SEQUENCE (SIZE (0..maxRoutingBlocks))
                              OF RoutingCombo,
      encrypted         [332] SEQUENCE (SIZE (0..maxRoutingBlocks))
                              OF OCTET STRING
    },
    -- contains the secret of the header block
    forwardSecret     ChainSecret,
    -- contains a routing block which may be used when sending
    -- error messages back to the quota owner
    -- this routing block may be cached for future use
    replyBlock [131]   SEQUENCE {
         murb           RoutingBlock,
         maxReplay      INTEGER,
         validity       UsagePeriod
    } OPTIONAL,
  }
  
  RoutingCombo ::= SEQUENCE {
    -- The message key to encrypt the message
    messageKey    [401] SymmetricKey OPTIONAL,
    -- contains the next recipient
    recipient BlendingSpec OPTIONAL, 
    -- PrefixBlock encrypted with message key
    mPrefix       OCTET STRING OPTIONAL, 
    -- PrefixBlock encrypted with sender key
    cPrefix       OCTET STRING OPTIONAL, 
    -- HeaderBlock encrypted with sender key
    header        OCTET STRING OPTIONAL, 
    -- RoutingBlock encrypted with sender key
    routing       OCTET STRING OPTIONAL, 
    -- contains information for building messages (when used as MURB
    -- ID 0 denotes original message; ID 1-maxPayloadBlocks denotes 
    -- target message; 32768-maxWorkspaceId shared workspace for all 
    -- blocks of this identity)
    assembly      SEQUENCE (SIZE (0..maxAssemblyInstructions))
                  OF PayloadOperation,
    validity      UsagePeriod
  }

  InnerMessageBlock ::= SEQUENCE {
    padding   OCTET STRING,
    prefix    CHOICE {
        plain           [11011] PrefixBlock,
        -- contains prefix encrypted with receivers public key
        encrypted       [11012] OCTET STRING
    },
    identity  CHOICE  {
      -- debug/internal use only
      plain     [11021] HeaderBlock,
      -- contains encrypted identity block
      encyrpted [11022] OCTET STRING
    },
    -- contains signature of Identity [as stored in
    -- HeaderBlock; signed unencrypted HeaderBlock without Tag]
    identitySignature OCTET STRING,
    -- contains routing information (next hop) for the payloads
    routing     CHOICE {
      plain     [11031] SEQUENCE (SIZE (1..maxRoutingBlocks))
                        OF RoutingBlock,
      -- contains encrypted routing block
      encyrpted [11032] OCTET STRING
    },
    -- contains the actual payload
    payload     SEQUENCE (SIZE (0..maxPayloadBlocks)) 
                OF PayloadChunk
  }

  -- do not use this for encoding (internal structure only)
  VortexMessage ::= SEQUENCE {
    prefix        CHOICE {
        plain           [10011] PrefixBlock,
        -- contains prefix encrypted with receivers public key
        encrypted       [10012] OCTET STRING
    },
    innerMessage  CHOICE {
        plain     [10021] InnerMessageBlock,
        -- contains inner message encrypted with Symmetric key from
        -- Prefix
        encrypted [10022] OCTET STRING
    }
  }

  PrefixBlock ::= SEQUENCE {
    key             SymmetricKey
  }

  PuzzleIdentifier          ::= OCTET STRING ( SIZE(0..16) )

  HeaderBlock ::= SEQUENCE {
    -- Public key of the identity representing this transmission
    identityKey        AsymmetricKey,
    -- serial identifying this block
    serial             INTEGER (0..maxSerial),
    -- number of times this block may be replayed (Tuple is
    -- identityKey, serial while UsagePeriod of block)
    maxReplays         INTEGER (0..maxNumberOfReplays),
    -- subsequent Blocks are not processed before valid time.
    -- Host may reject too long retention. Recomended validity
    -- support >=1Mt.
    valid              UsagePeriod,
    -- represents the chained secret which has to be found in
    -- subsequent blocks
    -- prevents reassembly attack
    forwardSecret       ChainSecret,
    --  contains the MAC-Algorithm used for signing
    signAlgorithm       MacAlgorithm,
    -- contains administrative requests such as quota requests
    requests            SEQUENCE (SIZE (0..maxNumberOfRequests))
                        OF HeaderRequest ,
    -- padding and identitifier required to solve the cryptopuzzle
    identifier  [12201] PuzzleIdentifier OPTIONAL,
    -- This is for solving crypto puzzles
    proofOfWork [12202] OCTET STRING OPTIONAL
  }

  PayloadOperation ::= CHOICE {
    splitPayload    [150] SplitPayloadOperation,
    mergePayload    [160] MergePayloadOperation,
    xorSplitPayload [250] XorSplitPayloadOperation,
    xorMergePayload [260] XorMergePayloadOperation,
    encryptPayload  [300] EncryptPayloadOperation,
    decryptPayload  [310] DecryptPayloadOperation,
    addRedundancy   [400] AddRedundancyOperation,
    removeRedundancy[410] RemoveRedundancyOperation
  }

  PercentSizeBlock ::= SEQUENCE {
    fromPercent         INTEGER (0..100),
    toPercent           INTEGER (0..100)
  }

  AbsoluteSizeBlock ::= SEQUENCE {
    fromAbsolute        INTEGER (0..maxChunkSize),
    toAbsolute          INTEGER (minChunkSize..maxChunkSize)
    -- negative toAbsolute denominates end in absolute value 
    -- specified from the end of block
  }

  SizeBlock ::= SEQUENCE{
    size CHOICE {
      percent     [15001] PercentSizeBlock,
      absolute    [15101] AbsoluteSizeBlock
    }
  }

  AddRedundancyOperation ::= SEQUENCE {
    inputId            [16000] INTEGER (0..maxID),
    dataStripes        [16001] INTEGER (1..254),
    redundancy         [16002] INTEGER (1..254),
    keys               [16003] SEQUENCE (SIZE (2..512))
                               OF SymmetricKey,
    outputId           [16004] INTEGER (1..maxID),
    gfSize             [16005] INTEGER (2..maxGFSize)
  }

  RemoveRedundancyOperation ::= SEQUENCE {
    inputId            [16000] INTEGER (0..maxID),
    dataStripes        [16001] INTEGER (1..254),
    redundancy         [16002] INTEGER (1..254),
    keys               [16003] SEQUENCE (SIZE (2..512))
                               OF SymmetricKey,
    outputId           [16004] INTEGER (1..maxID),
    gfSize             [16005] INTEGER (2..maxGFSize)
  }

  SplitPayloadOperation ::= SEQUENCE {
    originalId         INTEGER (0..maxID),
    firstSize          SizeBlock,
    newFirstId         INTEGER (1..maxID),
    newSecondId        INTEGER (1..maxID)
  }

  MergePayloadOperation ::= SEQUENCE {
    originalFirstId      INTEGER (0..maxID),
    originalSecondId     INTEGER (0..maxID),
    newId                INTEGER (1..maxID)
  }

  XorMergePayloadOperation ::= SEQUENCE {
    originalFirstId      INTEGER (0..maxID),
    originalSecondId     INTEGER (-1..maxID),
    originalSize         SizeBlock,
    newId                INTEGER (1..maxID)
  }

  XorSplitPayloadOperation ::= SEQUENCE {
    originalId           INTEGER (0..maxID),
    prngSpec             PRNGAlgorithmIdentifier,
    newFirstBlockId      INTEGER (1..maxID),
    newSecondBlockId     INTEGER (1..maxID)
  }

  EncryptPayloadOperation ::= SEQUENCE {
    originalId            INTEGER (0..maxID),
    key                   SymmetricKey,
    newId                 INTEGER (1..maxID)
  }

  DecryptPayloadOperation ::= SEQUENCE {
    originalId            INTEGER (0..maxID),
    key                   SymmetricKey,
    newId                 INTEGER (1..maxID)
  }

  IdentityReplayStore ::= SEQUENCE {
    replays   SEQUENCE (SIZE (0..4294967295)) 
              OF IdentityReplayBlock
  }

  IdentityReplayBlock ::= SEQUENCE {
    identity            AsymmetricKey,
    valid               UsagePeriod,
    replaysRemaining  INTEGER (0..4294967295)
  }

  IdentityStore ::= SEQUENCE {
    identities SEQUENCE (SIZE (0..4294967295)) 
               OF IdentityStoreBlock
  }

  IdentityStoreBlock ::= SEQUENCE {
    valid               UsagePeriod,
    messageQuota        INTEGER (0..maxMessageQuota),
    transferQuota       INTEGER (0..maxTransferQuota),
    -- if omitted this is a node identity
    identity            [1001] AsymmetricKey OPTIONAL,
    -- if ommited own identity key
    nodeAddress         [1002] NodeSpec      OPTIONAL,
    -- Contains the identity of the owning node;
    -- May be ommited if local node
    nodeKey             [1003] SEQUENCE OF AsymmetricKey OPTIONAL,
    routingBlocks       [1004] SEQUENCE OF RoutingBlock OPTIONAL,
    replayStore         [1005] IdentityReplayStore,
    puzzle              [1006] RequirementPuzzleRequired OPTIONAL
  }

  -- contains a node spec of a routing point
  -- At the moment either smtp:<email> or xmpp:<jabber>
  BlendingSpec ::= SEQUENCE {
    target            NodeSpec,
    blendingType      UTF8String,
    parameter         SEQUENCE ( SIZE (0..maxNumberOfParameter) )
                      OF BlendingParameter
  }

  BlendingParameter ::= CHOICE {
    offset          [1] INTEGER,
    symmetricKey    [2] SymmetricKey,
    asymmetricKey   [3] AsymmetricKey,
    blendingType    [4] UTF8String
   }

  NodeSpec ::= SEQUENCE {
    Transportprotocol Protocol,
    recipientAddress  UTF8String
  }

  ChainSecret ::= INTEGER (0..4294967295)

  HeaderRequest ::= CHOICE {
    identity      [0] HeaderRequestIdentity,
    capabilities  [1] HeaderRequestCapability,
    messageQuota  [2] HeaderRequestIncreaseMessageQuota,
    transferQuota [3] HeaderRequestIncreaseTransferQuota,
    quotaQuery    [4] HeaderRequestQueryQuota
  }

  ReplyBlock ::= CHOICE {
    capabilities  [1]  ReplyCapability,
    puzzle        [2]  RequirementPuzzleRequired,
    status        [99] StatusBlock
  }

  HeaderRequestIdentity ::= SEQUENCE {
    period UsagePeriod
  }

  RequirementPuzzleRequired ::= SEQUENCE {
    -- bit sequence at beginning of hash from encrypted identity 
    -- block
    challenge     BIT STRING,
    hash          MacAlgorithmIdentifier,
    valid         UsagePeriod,
    identifier    INTEGER (0..4294967295)
  }

  HeaderRequestQueryQuota ::= SEQUENCE {
  }

  HeaderRequestIncreaseMessageQuota ::= SEQUENCE {
    messages INTEGER (0..4294967295)
  }

  HeaderRequestIncreaseTransferQuota ::= SEQUENCE {
    size     INTEGER (0..4294967295)
  }

  HeaderRequestCapability ::= SEQUENCE {
    period UsagePeriod
  }

  ReplyCapability ::= SEQUENCE {
    cipher            SEQUENCE (SIZE (2..256)) OF CipherSpec,
    maxTransferQuota  INTEGER (0..4294967295),
    maxMessageQuota   INTEGER (0..4294967295),
    supportedBlendingIn SEQUENCE OF BlendingSpec
  }

  CipherSpec ::= SEQUENCE {
      asymmetric [16001] AsymmetricAlgorithmSpec OPTIONAL,
      symmetric  [16002] SymmetricAlgorithmSpec OPTIONAL,
      mac        [16003] MacAlgorithmSpec OPTIONAL,
      cipherUsage[16004] CipherUsage
  }

  CipherUsage ::= ENUMERATED {
    sign     (200),
    encrypt  (210)
  }

  Protocol ::= ENUMERATED {
    smtp  (100),
    xmmp  (110),
  }

  StatusBlock ::= SEQUENCE {
    code            StatusCode,
    request         HeaderRequest
  }

  StatusCode ::= ENUMERATED {

    -- System messages
    ok                          (2000),
    transferQuotaStatus         (2101),
    messageQuotaStatus          (2102),
    puzleRequired               (2201),

    -- protocol usage failures
    transferQuotaExceeded       (3001),
    messageQuotaExceeded        (3002),
    identityUnknown             (3101),
    messageChunkMissing         (3201),
    messageLifeExpired          (3202),
    puzzleUnknown               (3301),

    -- capability errors
    macAlgorithmUnknown         (3801),
    symmetricAlgorithmUnknown   (3802),
    asymmetricAlgorithmUnknown  (3803),
    prngAlgorithmUnknown        (3804),
    missingParameters           (3820),
    badParameters               (3821),

    -- Mayor host specific errors
    hostError                   (5001),
    ...
  }

  PayloadChunk ::= SEQUENCE {
    id                        INTEGER (0..maxID),
    payload                   CHOICE {
      payload                   [100] OCTET STRING,
      replyBlock                [101] ReplyBlock
    }
  }

  UsagePeriod ::= SEQUENCE {
    notBefore       [0]     GeneralizedTime OPTIONAL,
    notAfter        [1]     GeneralizedTime OPTIONAL
  }

  SymmetricAlgorithmSpec  ::=  SEQUENCE  {
    algorithm               SymmetricAlgorithm,
    padding                 CipherPadding,
    mode                    CipherMode,
    parameter               AlgorithmParameters OPTIONAL
  }

  AsymmetricAlgorithmSpec  ::=  SEQUENCE  {
    algorithm               AsymmetricAlgorithm,
    parameter               AlgorithmParameters OPTIONAL
  }

  MacAlgorithmSpec  ::=  SEQUENCE  {
    algorithm               MacAlgorithm,
    parameter               AlgorithmParameters
  }

  PRNGAlgorithmSpec ::= SEQUENCE {
    type                    PRNGType,
    seed                    OCTET STRING
  }

  PRNGType ::= ENUMERATED {
    xsadd           (1000),
    blumMicali      (1001)
  }

  SymmetricAlgorithm ::= ENUMERATED {
    aes128          (1000),  -- required
    aes192          (1001),  -- optional support
    aes256          (1002),  -- required
    camellia128     (1100),  -- required
    camellia192     (1101),  -- optional support
    camellia256     (1102),  -- required
    twofish128      (1200),  -- optional support
    twofish192      (1201),  -- optional support
    twofish256      (1202)   -- optional support
  }

  CipherMode ::= ENUMERATED {
    -- ECB is a really bad choice. Do not use unless really 
    -- necessary
    ecb             (10000),
    cbc             (10001),
    eax             (10002),
    ctr             (10003),
    ccm             (10004),
    gcm             (10005),
    ocb             (10006),
    ofb             (10007),
    none            (10100)
  }

  CipherPadding ::= ENUMERATED {
    pkcs7           (1000),
    pkcs1           (1001)
  }

  AsymmetricAlgorithm ::= ENUMERATED {
    rsa             (2000),
    dsa             (2100),
    ec              (2500)
  }

  MacAlgorithm ::= ENUMERATED {
    sha256          (3000),
    sha384          (3001),
    sha512          (3002),
    ripemd160       (3100),
    ripemd256       (3101),
    ripemd320       (3102)
  }

  ECCurveType ::= ENUMERATED{
    secp384r1       (2500),
    sect409k1       (2501),
    secp521r1       (2502),
  }

  AlgorithmParameters ::= SEQUENCE {
    keySize              [10000] INTEGER (0..65535) OPTIONAL,
    curveType            [10001] ECCurveType   OPTIONAL,
    initialisationVector [10002] OCTET STRING  OPTIONAL,
    nonce                [10003] OCTET STRING  OPTIONAL,
    mode                 [10004] CipherMode    OPTIONAL,
    padding              [10005] CipherPadding OPTIONAL
  }

  -- Symmetric key
  SymmetricKey ::= SEQUENCE {
    keyType SymmetricAlgorithmIdentifier,
    parameter AlgorithmParameters,
    key     OCTET STRING (SIZE(1..512))
  }

  -- Asymmetric Key
  AsymmetricKey ::= SEQUENCE {
    keyType       AsymmetricAlgorithmIdentifier,
    publicKey     [2] OCTET STRING,
    privateKey    [3] OCTET STRING OPTIONAL
  }

END
                ]]></artwork>
            </figure>
        </section>
        <!-- Change Log

            v00 2018-04-19  GwM   Initial version

        -->
    </back>
</rfc>
